# 笔试 暑期实习 牛客真题 oj在线编程 OJ在线编程常见输入输出练习 acm模式

一般企业会用到以下几个平台：

牛客网：腾讯、美团等大中小厂；
赛码网：360、顺丰、字节和小红书等大中小厂；
其他小平台或自建平台：阿里等
一般企业都是选择前两个比较大的平台作为笔试的合作方，所以后面我会重点对这两个平台下的一些规则进行梳理。

该类在线测试系统也被称为 OJ (Online Judge)，即在线判题系统，是一种在编程竞赛中用来测试参赛程序的在线系统，也可以用于平时练习。关于该系统也有一些专业的术语和规则，如：
判题时经常会出现的评测状态有：


赛制：
OI 赛制：传统的赛制，比赛期间不能看到结果。以最后一次提交为准。
ACM 赛制：比赛时可以看到结果，必须 AC 了这道题目才会计分，会记录AC 这道题的耗时，每次失败的提交会加上 20 分钟的罚时。通过题目数多的排名在前；通过数一样的耗时少排名靠前。
乐多赛制：洛谷网站独创赛制。结合了 OI 赛制和 ACM 赛制的优点，既可以按照题目的测试点分点得分，也不失比赛的刺激。比赛时可以看到结果。对于一道题的得分，计算为（评测得分*0.95^(本题提交次数-1)），最低扣到原来的 70% 为止。
IOI 赛制：最不刺激的赛制，比赛时可以看到结果，计分按照这道题目的


## 输入方法汇总
输入描述：
包含多组测试用例。
对于每组测试用例：
第一行包括2个整数，N ( 1 < = N < = 1000 ) N(1 <= N <= 1000)N(1<=N<=1000)，M ( 0 < = M < = N ∗ ( N − 1 ) / 2 ) M(0 <= M <= N*(N-1)/2)M(0<=M<=N∗(N−1)/2)，代表现有 N NN 个人（用 1 ∼ N 1 \sim N1∼N 编号）和 M MM 组关系；
在接下来的 M MM 行里，每行包括3个整数，a aa，b bb， c cc，如果 c cc 为1，则代表 a aa 跟 b bb 是同乡；如果 c cc 为0，则代表a aa 跟 b bb 不是同乡；
已知1表示小赛本人。

    输入样例：
    3 1
    2 3 1
    5 4
    1 2 1
    3 4 0
    2 5 1
    3 2 1

所以要是我看到这个问题描述，直接就蒙了，我就会误以为，输入跟我没关系，默认每个输入就是一个测试用例，所以上面的输入样例中，是包含两个测试样例的，第1-2行和第3-7行。


    import math
    while 1: # 每一次循环针对一个测试样例
        #每组第一行是N和M 
        nm = list(map(int,input().split(" "))) # 每一个input()函数都针对一行输入
        N = nm[0]
        M = nm[1]
        print(str(N) + ' ' + str(M))
        # 接下来M行，每行a b c
        for i in range(M):
        abc = list(map(int,input().split(" "))) # 这里就针对除第一行输入外的其他行的输入
        a = abc[0]
        b = abc[1]
        c = abc[2]
        print(str(a) + ' ' + str(b) + ' ' + str(c))


1.2 各种输入输出的情况总结
python 语言中的输入一般使用 input() 或 sys.stdin.readline，一般使用前者即可，使用 print() 进行输出。

1.2.1 单个输入，单个输出

    input = int(input())
    output = input
    print(str(output))

1.2.2 单行多个输入，单行多个输出，空格分割（多行输入，每一行是一个测试样例）

    inputs = list(map(int, input().split(" ")))
    m, n = inputs[0], input[1]
    print(str(m), str(n))

1.2.3 多个测试案例，每个测试案例多行

    while 1:
        nm = list(map(int,input().split(" ")))
        N = nm[0]
        M = nm[1]
        print(str(n)+' '+str(m))
        for i in range(m):
            abc = list(map(int, input().split(" ")))
            a, b, c = abc[0], abc[1], abc[2]
            print(str(a)+' '+str(b)+' '+str(c))


牛客网建议使用 sys.stdin.readline() 获取输入，使用 print() 进行输出。
输入用空格隔开，如果要用 , 隔开，使用 .split(",")

2.1 多行输入，每一行是一个测试样例

    import sys 
    for line in sys.stdin:
        a = line.split()
        print(int(a[0]) + int(a[1]))

2.2 多个测试用例，每个测试用例有多行
输入包含多组测试用例。对于每组测试用例：第一行包含两个整数N和M，在接下来的M行内，每行包括3个整数。要求按照输入格式输出。

    import sys
    for line in sys.stdin:
        n, m = map(int, line.strip().split())
        print(n, m)
        for i in range(m):
            for line in sys.stdin:
                a, b, c = map(int, line.strip().split())
                print(a, b, c)5861/article/details/131903084















## 练习1 循环行读取 for line in sys.stdin 一次读完所有
输出描述：
输出a+b的结果
示例1

    输入例子：
    1 5
    10 20
    输出例子：
    6
    30
解答

    import sys

    for line in sys.stdin: 循环行读取，应该是被读取成一个iterate了 列表还是其他什么结构位置 应该就是next输出 或者是yield
        a = line.split() 行读取 切分空格 列表返回
        print(int(a[0]) + int(a[1]))


## 练习2 按行读取 input()
输出描述：
输出a+b的结果
示例1

    输入例子：
    2
    1 5
    10 20
    输出例子：
    6
    30

答案

    import sys
    
    n = int(input())
    for _ in range(n):
        ls = list(map(int, input().split()))
        print(ls[0] + ls[1])



## 练习3 
输出描述：
输出一行排序后的字符串，空格隔开，无结尾空格
示例1

    输入例子：
    5
    c d a bb e
    输出例子：
    a bb c d e

## 练习4 map直接用于整个list 而且返回值需要再转回list。int直接用不需要括号int()
    for line in sys.stdin:
        a = line.split()
        b = list(map(int, a))
        print(sum(b))

加括号会导致       
Exception has occurred: TypeError
'int' object is not callable
  File "C:\Users\13162\Desktop\工作\多模\leetcode\test.py", line 25, in <module>
    b = list(map(int(), a))
        ^^^^^^^^^^^^^^^^^^^
TypeError: 'int' object is not callable


b = list(map(int, "1"))       
也可以单个直接用 当成列表处理 好像之前有个函数也是这种逻辑         
[1]

# oppo真题
## 第一题 n, m, k = map(int, input().split())
题意：给你 x, y, k 三个正整数，每次可以选择以下操作之一

    x = x - 1
    x = x / k 当且仅当 x % k == 0
问你将 x 变为 y 的最小操作次数。

输入：

三个正整数，

输出

一行一个正整数，表示最小操作次数

样例

输入：

10 4 2

输出

2

思路与代码   
贪心，若  x % k != 0 ，将 x 减少到能整除为止，只到不能整除且大于等于 y ，然后操作1即可。

n, m, k = map(int, input().split())

竟然可以这样


    def solve() -> None:
        n, m, k = map(int, input().split())
        if k == 1:
            print(m - n)
            return
        ans = 0
        
        while n != m:
            if n // k >= m:
                ans += n % k 这个地方太巧妙 不能说简单吧 
                n //= k 题目只给/ - % 竟然能联想到用 // 来减少运算
            else:
                n -= 1 
            ans += 1
        print(ans)    

    if __name__ == '__main__':
        solve()


按照 10 1 3的例子 我肯定会进入else 但是这个方法进竟然没进入


写得比较巧妙 加大理解难度



## 第二题 counter。 for k, v in cnta.items(), from collections import Counter
题意
小O有一个字符串 s，她希望重新排列这个字符串，并改变字符的大小写，使得新的字符串包含尽可能多的字符串 a 或者字符串 b 。请问小O最多能包含多少个子串 a 和 b ， 如果字符串t可以通过从字符串s的开头删除若干(可能为零或全部)字符以及字符串 s 的结尾删除若干(可能为零或全部)字符得到，则字符串 t 是字符串 s 的子串。

输入：

三行三个字符串，s, a, b 其中 a和b开头均为大写，其余均为小写

输出：

包含的子串个数

样例

输入：

    abcdefg
    Abc
    Fge
输出：

2


文字太多

由于 a 和 b 的首字母大写，所有不存在重叠，那么考虑贪心，枚举有多少个 a ,然后计算剩下的字符能组成多少个 b，取最大值即可

题解看不懂

    def solve() -> None:
        s = input()
        a = input()
        b = input()
        s = [x.lower() for x in s]
        a = [x.lower() for x in a]
        b = [x.lower() for x in b]
        cnts = Counter(s)
        cnta = Counter(a)
        cntb = Counter(b)
        ans = 0
        for i in range(len(s)+1):
            ok = True
            for k, v in cnta.items():
                if cnts[k] < i * v:
                    ok = False
            if ok:
                now = len(s)
                for k, v in cntb.items():
                    now = min(now, (cnts[k] - i * cnta[k]) // v)
                ans = max(ans, i + now)
        print(ans)

    if __name__ == '__main__':
        solve()

还是比较难的



这他妈还比较简单？ 两个for循环 一个min中带有// 还有一个max

true false循环设置 以及ok定义完全不知道在干什么

这三行代码使用 Counter 计算每个字符在字符串 s、a 和 b 中出现的频率。cnts、cnta 和 cntb 是三个字典，分别记录了字符及其出现次数。

ok 被用来检查在 s 中是否有足够的字符来满足 i 个字符串 a。

不要求顺序吗


for k, v in cnta.items(): 检查 cnts 中每个字符是否有足够的数量来满足 i 个 a 字符串的需求。   
如果满足条件，计算剩余字符能组成多少个 b 字符串，并更新最大值 ans。    
ans = max(ans, i + now): 通过比较当前计算的值和之前的最大值来更新 ans。   

这段代码的目的是从三个字符串 s、a 和 b 中计算一个最大值 ans。这个值表示你可以从字符串 s 中提取出尽可能多的字符串 a，然后用剩下的字符构造尽可能多的字符串 b。最终，ans 是这些字符串 a 和 b 组合的最大值。


确实牛逼

小O有一个字符串 s，她希望重新排列这个字符串，并改变字符的大小写，使得新的字符串包含尽可能多的字符串 a 或者字符串 b 。请问小O最多能包含多少个子串 a 和 b ， 如果字符串t可以通过从字符串s的开头删除若干(可能为零或全部)字符以及字符串 s 的结尾删除若干(可能为零或全部)字符得到，则字符串 t 是字符串 s 的子串。

题意好像比较矛盾


    now = len(s)
    for k, v in cntb.items():
        now = min(now, (cnts[k] - i * cnta[k]) // v)

如果满足条件，计算剩余字符能组成多少个 b 字符串，并更新最大值 ans。

整个下来挺绕 边界问题竟然被倒逼处理这么好

// v 不太懂是为什么

now = min(now, (cnts[k] - i * cnta[k]) // v)

这句代码 now = min(now, (cnts[k] - i * cnta[k]) // v) 的作用是计算在当前情况下，字符 k 能够满足的最大数量，并更新 now 为其最小值。它是用于确定在 i 个 a 组成的字符串后，剩下的字符能组成的 b 字符串的数量。


// v 是为了计算在剩余字符中，能够组成多少个 b 中需要的字符 k。即通过整数除法确定剩余的字符数量除以每个 b 字符串所需的字符数 v，从而得到可以组成的 b 字符串的数量。

假设我剩下 5个，v=5，那么//v得到1个？

ChatGPT 说：
ChatGPT
是的，正如你所理解的，如果剩下 5 个字符，而每个 b 字符串需要 5 个这样的字符，那么 5 // 5 的结果是 1。这个结果表示，在剩下的字符中，你最多可以组成 1 个 b 字符串。

在这段代码中，// v 用来确定你能用剩余的字符来组成多少个 b 字符串。这里的逻辑是将剩余的字符数除以每个 b 字符串需要的字符数，从而确定最多可以组成多少个 b 字符串。


原来如此





## 第三题

题意
给你一颗树，包含 n 个节点和 n-1 条边，你可以在树中选两个节点进行连无向边，要求连边后的无向图是二分图，问你能连接的最多的边的个数。

输入：

一行一个整数 n, 接下来 n-1 行输入树的边

输出：

能增加的最多的边的条数

样例

输入：

    4
    1 2
    2 3
    3 4
输出：

2


一看就看不懂

本次比试难度适中，没有特别刁钻的题目。第一题简单的贪心，分析一下不难写出来。第二题也是基础的哈希的应用，难度不大。第三题是经典图论问题，dfs遍历即可，注意不要重复遍历。

这他妈


二分图染色，将节点分为两个集合，那么两个集合的点相互连边，这样可以保证结果仍是二分图。假设两个集合个数为 x, y=n-x , 那么答案为 x*y-(n-1)

二分图の定义

        二分图又叫二部图，是图论中的一种特殊模型。

        假设S=(V,E)是一个无向图。如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边(i,j)所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，就可以称图S为一个二分图。简单来说，就是顶点集V可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。

![alt text](assets_picture/牛客题/image.png)

已经很像数学题了        

这题完全不懂


二分图（Bipartite Graph）是一种特殊的图，其中的节点可以被分成两个独立的集合，使得图中的每条边都连接这两个集合中的一个节点。换句话说，二分图中的节点集合可以被划分成两个互不相交的集合，使得所有的边都只在这两个集合之间连接，而不在同一集合内部连接。

图像示例
考虑一个简单的二分图示例：

图 1

    1      2
    |      |
    3      4
这个图是一个二分图，因为你可以将节点分为两组：

集合 𝑈
={
1
,
4
}
U={1,4}

集合 𝑉
={
2
,
3
}
V={2,3}


{竟然可以当成标题

所有的边都连接这两个集合的一个节点。具体来说：

边 
(
1
,
2
)
(1,2) 连接 
𝑈
U 中的节点 1 和 
𝑉
V 中的节点 2。
边 
(
1
,
3
)
(1,3) 连接 
𝑈
U 中的节点 1 和 
𝑉
V 中的节点 3。
边 
(
2
,
4
)
(2,4) 连接 
𝑉
V 中的节点 2 和 
𝑈
U 中的节点 4。
边 
(
3
,
4
)
(3,4) 连接 
𝑉
V 中的节点 3 和 
𝑈
U 中的节点 4。
你可以看到，这个图没有包含奇数长度的环（例如长度为 3 的环），所以它是一个二分图。


图 2（不是二分图）

    1
    / \
    2 - 3
这个图不是二分图，因为它包含了一个长度为 3 的环（1 → 2 → 3 → 1）。在二分图中，我们无法将其节点分为两个集合，使得每条边都连接不同集合中的节点。


如何判断一个图是否是二分图        
判断一个图是否是二分图的一种常用方法是使用 广度优先搜索（BFS） 或 深度优先搜索（DFS） 来尝试对图进行二分着色。如果在搜索过程中发现两个相邻的节点被着上了相同的颜色，则图不是二分图。




二分图（Bipartite Graph）是一种特殊的图，其中的节点可以被分成两个独立的集合，使得图中的每条边都连接这两个集合中的一个节点。换句话说，二分图中的节点集合可以被划分成两个互不相交的集合，使得所有的边都只在这两个集合之间连接，而不在同一集合内部连接。

二分图的性质
节点划分: 二分图的节点集合可以被划分为两个集合 
𝑈
U 和 
𝑉
V，使得每条边的两个端点分别属于这两个集合中的一个。
无奇环: 一个图是二分图的当且仅当它不包含奇数长度的环（循环）。即，二分图不能包含任何长度为奇数的环。
图的着色: 二分图可以用两种颜色来着色，使得相邻的节点颜色不同。
图像示例
考虑一个简单的二分图示例：

图 1
yaml
复制代码
   1      2
   |      |
   3      4
这个图是一个二分图，因为你可以将节点分为两组：

集合 
𝑈
={
1
,
4
}
U={1,4}
集合 
𝑉
={
2
,
3
}
V={2,3}
所有的边都连接这两个集合的一个节点。具体来说：

边 
(
1
,
2
)
(1,2) 连接 
𝑈
U 中的节点 1 和 
𝑉
V 中的节点 2。
边 
(
1
,
3
)
(1,3) 连接 
𝑈
U 中的节点 1 和 
𝑉
V 中的节点 3。
边 
(
2
,
4
)
(2,4) 连接 
𝑉
V 中的节点 2 和 
𝑈
U 中的节点 4。
边 
(
3
,
4
)
(3,4) 连接 
𝑉
V 中的节点 3 和 
𝑈
U 中的节点 4。
你可以看到，这个图没有包含奇数长度的环（例如长度为 3 的环），所以它是一个二分图。

图 2（不是二分图）
复制代码
   1
  / \
 2 - 3
这个图不是二分图，因为它包含了一个长度为 3 的环（1 → 2 → 3 → 1）。在二分图中，我们无法将其节点分为两个集合，使得每条边都连接不同集合中的节点。

如何判断一个图是否是二分图
判断一个图是否是二分图的一种常用方法是使用 广度优先搜索（BFS） 或 深度优先搜索（DFS） 来尝试对图进行二分着色。如果在搜索过程中发现两个相邻的节点被着上了相同的颜色，则图不是二分图。

示例代码
下面是一个使用 BFS 判断一个图是否是二分图的 Python 代码示例：


    from collections import deque, defaultdict

    def is_bipartite(graph, start):
        color = {}
        queue = deque([start])
        color[start] = 0
        
        while queue:
            node = queue.popleft()
            current_color = color[node]
            
            for neighbor in graph[node]:
                if neighbor not in color:
                    color[neighbor] = 1 - current_color
                    queue.append(neighbor)
                elif color[neighbor] == current_color:
                    return False
        
        return True

    def check_bipartite(graph):
        for node in graph:
            if node not in color:
                if not is_bipartite(graph, node):
                    return False
        return True

    # 图的表示：邻接列表
    graph = {
        1: [2, 3],
        2: [1, 3],
        3: [1, 2]
    }

    color = {}
    print("The graph is bipartite:" if check_bipartite(graph) else "The graph is not bipartite.")
在这个示例中，graph 是一个用邻接列表表示的图。如果图是二分图，程序将输出“图是二分图”；否则，输出“图不是二分图”。


    def solve() -> None:
        n = sint()
        adj = [[] for _ in range(n)]
        for i in range(n - 1):
            x, y = mint()
            adj[x - 1].append(y - 1)
            adj[y - 1].append(x - 1)
        m = 0
        def dfs(u, fa, c):
            nonlocal m
            if not c:
                m += 1
            for v in adj[u]:
                if v != fa:
                    dfs(v, u, not c)
        dfs(0, -1, False)
        print(m * (n - m) - (n - 1))
        

    if __name__ == '__main__':
        solve()


    n = map(int, input().split()) 竟然不行
    adj = [[] for _ in range(n)]
    for i in range(n - 1):
        x, y = map(int, input().split())
        adj[x - 1].append(y - 1)
        adj[y - 1].append(x - 1)


代码挺复杂 但是答案不对       
而且后处理很复杂     

        for v in adj[u]:
            if v != fa:
                dfs(v, u, not c)
    dfs(0, -1, False)
    print(m * (n - m) - (n - 1))

n 表示节点数，树的节点数量为 n。
adj 是一个邻接列表，用于表示树的边。
接下来，读入 n-1 条边，每条边连接两个节点 x 和 y。由于 Python 使用零索引，所以减去 1 来适应零索引的数组。


dfs 函数用于遍历树，并计算满足特定条件的节点数量。
u 是当前节点，fa 是父节点，c 是当前节点的颜色（布尔值）。c 从 False 开始。
如果 c 是 False（即节点 u 的颜色为 False），则增加计数 m。
遍历所有与 u 相邻的节点 v，递归调用 dfs，并切换颜色。


计算结果:


    print(m * (n - m) - (n - 1))
m 代表树的节点被染成 False 颜色的数量。
n - m 是树中被染成 True 颜色的节点数量。
m * (n - m) 计算了 False 节点与 True 节点之间边的数量的期望值。
n - 1 是树中总的边数，因为树有 n-1 条边。
结果是两个集合节点之间的边的数量减去 n - 1。


代码的目的是计算一个树的所有节点被分为两个集合后，这两个集合之间的边数的期望值。具体计算方式是通过对树进行二分颜色处理，统计每种颜色的节点数，然后计算这两个集合之间的边数减去树的总边数（n - 1）。

示例替代输入函数
你可以使用 Python 的内置 input() 函数替代 sint() 和 mint()，例如：


    def sint():
        return int(input().strip())

    def mint():
        return map(int, input().strip().split())

太扯了 辅助了也不懂

什么染色完全不明白

图论占比大吗


## 研发b卷

本次oppo的机考有些卷子出了之前的原题了，还没投的赶紧投了噢，oppo的招聘持续性没有那么强的！

本次比试难度适中。

第1题打卡题，分析出来可以直接秒。

第2题需要分析要求的特点，根据特性来运算，数据很大不能特别暴力。

第3题的n,m比较小，观察到这个点就会好做了。

































# 京东
8.10京东研发岗   
考点分别为：模拟、哈希表/二分查找、贪心+位运算


## 第一题：薯条哥醉酒

![alt text](assets_picture/牛客题/image-1.png)

![alt text](assets_picture/牛客题/image-2.png)

![alt text](assets_picture/牛客题/image-3.png)


![alt text](assets_picture/牛客题/image-4.png)


![alt text](assets_picture/牛客题/image-5.png)


    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]  # 北东南西四个方向
    x, y, dirc = 0, 0, 0  # 定义初始位置,初始前进的方向(北方向)

    s = input()

    for ch in s:
        if ch == 'W':
            x = x + dx[dirc]
            y = y + dy[dirc]
        elif ch == 'A':  # 逆时针旋转90度
            dirc = (dirc - 1 + 4) % 4
        elif ch == 'D':   # 顺时针旋转90度
            dirc = (dirc + 1) % 4

    print(x, y)


这才是人做的

## 第二题：求和对数。 哈希表特殊应用 以key作为 加减结果 的索引


![alt text](assets_picture/牛客题/image-6.png)


样例
输入

    3 4
    1 2 3
输出

    3

![alt text](assets_picture/牛客题/image-7.png)

把值直接当成键记录进去。    
半个counter()

    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    cnts = {}
    for i in range(n):
        if a[i] in cnts:
            cnts[a[i]] += 1
        else:
            cnts[a[i]] = 1
    res = 0
    for i in range(n):
        if k - a[i] in cnts:
            res += cnts[k - a[i]]
    print(res)

## 第三题：区间操作


![alt text](assets_picture/牛客题/image-8.png)


![alt text](assets_picture/牛客题/image-9.png)


样例
输入

    2
    5
    1 1 2 1 1
    5
    1 2 3 4 5
输出

    2
    4


![alt text](assets_picture/牛客题/image-10.png)


没看懂？


    def calc(n):
        cnt = 0
        while n > 0:
            if n & 1:
                n -= 1
            else:
                n //= 2
            cnt += 1
        return cnt

    def solve():
        n = int(input())
        a=list(map(int,input().split()))
        op=[0]*n
        for i in range(n):
            op[i]= calc(a[i])
        res = op[0]
        for i in range(1, n):
            res += max(0, op[i] - op[i - 1])
        print(res)

    t = int(input())
    while t > 0:
        solve()
        t -= 1


calc(n) 函数:

功能：计算将 n 变成 0 所需的步骤数。
逻辑：通过判断 n 是奇数还是偶数来决定操作。如果 n 是奇数，则减去 1；如果是偶数，则除以 2。每次操作都计数，直到 n 变成 0。


solve() 函数:

功能：处理每个测试用例，计算并输出结果。
逻辑：
读取整数 n 和包含 n 个整数的列表 a。
对每个整数计算步骤数，将结果存储在 op 列表中。
计算每个步骤数之间的差异，如果当前值大于前一个值，则累加到 res。

    示例：对于输入 n = 3 和 a = [4, 6, 5]：
    计算步骤数：op = [3, 4, 4]
    差异计算：res = 3 + max(0, 4-3) + max(0, 4-4) = 3 + 1 + 0 = 4




主循环:

功能：处理多个测试用例。
逻辑：读取测试用例数量 t，然后循环调用 solve() 函数处理每个测试用例。
示例：如果 t = 2，会依次处理两个测试用例的输入数据。
整体来说，代码的“ultimate”目标是计算和输出每个测试用例的最终结果，即所有数值的“变换步骤数”之和。

还是nlp牛逼


比如现在有3个数字，操作次数分别为2,3,2

那么其实，我们可以先让其操作2次区间，然后再让其操作1次区间即可得到答案。

那么对于第一个数字，我们是一定要花费来进行操作的，然后我们往后面遍历


这块不懂 操作都可以保持一致？万一一个加一个乘呢？


薯条哥有一个长度为且值都为的数组a。对于这个数组薯条哥每次操作可以选择一个区间，对于上的每一个数薯条哥必须让其加一或者乘二(元素之间操作独立，可以选择一些元素乘二，一些元素加一，但是区间内每个元素都要操作)。


始终是题意得问题 第一句和最后一句一直到最后才读懂





# 美团


## 第一题：偶数因子
简单

## 第二题：登录密码 ak没有评论不知道是不是真的,基本无评论，群里也常常推荐老题目，主营网站  万诺每个都有评论，主营教学付费

在线测评链接：https://www.sspnote.com/oj/3/342
题目描述
ak机准备登录美团，需要输入密码，ak机忘记了密码，只记得密码可能是字符串中的一个。ak机会按照密码的长度从小到大依次尝试每

个字符串，对于相同长度的字符串，ak机随机尝试，并且相同的密码只会尝试一次。ak机想知道，她最少需要尝试多少次才能登录成功，

最多需要尝试多少次才能登录成功。

ak机不会重新尝试已经尝试过的字符串。成功登录后会立即停止尝试。

![alt text](assets_picture/牛客题/image-11.png)


样例
输入

    4
    ab
    abc
    ab
    ac
    ac
输出

    1 2
样例解释

ak机可能按照 ["ab", "ac", "abc"] 的顺序尝试，第一次尝试成功，也可能按照 ["ac", "ab", "abc"] 的顺序尝试，第二次尝试成功。

ak机在尝试 "ac" 发现不正确后不会继续尝试 "ac"。



## 817万诺 算法五道俩小时
第一题挺麻烦的，就是字符串模拟，用正则就更工程化一点。

第二天题也比较简单，求gcd和prim就好了，接着就是按照题目要求模拟。

第三题需要一些小技巧，分析题目要求的性质也不会很难。


算法岗的1、2、4题为测开、客户端的三道题目

侧开


### 第一题 正则式写法？不做


题意
小美在处理外卖订单的时候，遇到一个任务，他需要判断一个给定的字符串是否符会特定的分类规则。

具体来说，我们需要判断一个字符串是否是一个有效的电子邮件地址、IP 地址或者电话号码。

电子邮件地址的格式为:username@domain.com，其中 username 和 domain 只能包含字母、数字和下划线。
IP 地址的格式为：xxx.xxx.xxx.xxx，其中 xxx 是 0 到 255 之间的整数。
电话号码的格式为：+国家码-区号-号码 ，其中 国家码 和 区号 只能包含数字，号码 可以包含数字和'#’。
输入描述

输入描述
第一行包含数据组数 n。

接下来的 n 行，每一行输入一个需要判断的字符串。

输出描述
对于每一行，输出判断的结果，可能的结果如下:

    如果是有效的电子邮件地址，输出 email。
    如果是有效的 IP 地址，输出 ip。
    如果是有效的电话号码，输出 phone。
    如果都不是，输出invalid。
示例：
输入：

    5
    user@example.com
    192.168.1.1
    +86-10-12345#78
    hello@world
    256.256.256.256
输出：

    email
    ip
    phone
    invalid
    invalid


思路与代码
模拟题，但是逻辑毕竟复杂，可以使用正则表达式来检查字符串是否符合给定的格式：电子邮件地址、IP 地址或电话号码。

    关于正则表达式匹配电子邮件地址、IP地址、电话号码的解释:

    电子邮件地址的正则表达式

    ^：表示字符串的开始。

    [a-zA-Z0-9_]+：匹配一个或多个字母（大小写均可）、数字或下划线。这部分用于匹配电子邮件的 "username" 部分。

    @：字面意义上的 '@' 符号，电子邮件地址的标准部分。

    [a-zA-Z0-9_]+：再次匹配一个或多个字母（大小写均可）、数字或下划线。这部分用于匹配电子邮件的 "domain" 部分。

    \\.com：匹配字面上的 ".com"。点号 (.) 在正则表达式中是一个特殊字符，代表任意字符，所以使用 \\. 来表示字面上的点号。

    $：表示字符串的结束。

    这个正则表达式只匹配以 ".com" 结尾的电子邮件地址，并且 "username" 和 "domain" 部分只能包含字母、数字和下划线。

    IP地址的正则表达式

    该正则表达式确保 IP 地址由四部分组成，每部分是 0 到 255 的整数，四部分之间由点号分隔。

    \d{1,2}：匹配 1 到 2 位的数字（0 到 99）。

    1\d{2}：匹配 100 到 199。

    2[0-4]\d：匹配 200 到 249。

    25[0-5]：匹配 250 到 255。

    ^：表示字符串的开始。

    (\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])：这个分组表达式用于匹配 0 到 255 之间的整数。

    \\.：匹配点号，IP 地址各部分的分隔符。

    $：表示字符串的结束。

    电话号码的正则表达式

    ^：表示字符串的开始。
    \\+：匹配加号 (+)，通常用于国际电话号码的开头。
    \\d+：匹配一个或多个数字，用于国家码。
    -：字面意义上的短划线，用于分隔国家码和区号。
    \\d+：再次匹配一个或多个数字，用于区号。
    -：又一个字面意义上的短划线，用于分隔区号和电话号码。
    [\\d#]+：匹配一个或多个数字或井号 (#)，用于电话号码。
    $：表示字符串的结束。
    这个正则表达式用于匹配国际电话号码，其中号码部分可以包含数字和井号。

我靠 直接正则表达式还写个毛

如果是写普通逻辑还好

第一题挺麻烦的，就是字符串模拟，用正则就更工程化一点。

字符串模拟通常指的是在编程题目中，对字符串的操作或处理进行模拟。这类题目一般要求你模拟某些字符串操作，如插入、删除、替换、反转、查找子串等，或者对字符串进行某种变换和处理。

举个例子：

假设有一道题目要求你模拟一个字符串的变换操作，比如将字符串中的所有元音字母（a, e, i, o, u）替换成数字1，其他字符保持不变。

问题描述：
给定一个字符串，请将其中的元音字母替换成数字1，返回处理后的字符串。

输入："hello world"

输出："h1ll1 w1rld"

解题思路：

遍历字符串的每一个字符。
如果字符是元音字母，替换为数字1。
其余字符保持不变。
将最终的字符串返回。
示例代码（Python）：

    python
    复制代码
    def replace_vowels(s):
        vowels = "aeiouAEIOU"
        result = []
        for char in s:
            if char in vowels:
                result.append('1')
            else:
                result.append(char)
        return ''.join(result)

    # 测试
    input_str = "hello world"
    output_str = replace_vowels(input_str)
    print(output_str)  # 输出："h1ll1 w1rld"
总结：
字符串模拟题目主要考察的是对字符串的操作和处理能力。通常要求熟练使用字符串操作的基本方法和技巧，比如遍历、索引、切片、拼接等。

    def is_valid_email(s):
        if '@' not in s or s.count('@') != 1:
            return False
        username, domain = s.split('@')
        if '.' not in domain or domain.count('.') != 1:
            return False
        domain_name, domain_suffix = domain.split('.')
        
        if (username.isalnum() or '_' in username) and (domain_name.isalnum() or '_' in domain_name) and domain_suffix.isalnum():
            return True
        return False


如果能直接复制确实好

    def is_valid_ip(s):
        parts = s.split('.')
        if len(parts) != 4:
            return False
        for part in parts:
            if not part.isdigit() or not 0 <= int(part) <= 255:
                return False
        return True



    def is_valid_phone(s):
        if not s.startswith('+'):
            return False
        parts = s[1:].split('-')
        if len(parts) != 3:
            return False
        country_code, area_code, number = parts
        if not country_code.isdigit() or not area_code.isdigit():
            return False
        for ch in number:
            if not ch.isdigit() and ch != '#':
                return False
        return True

将 username.isalnum() 转换为二进制处理的方式会显得比较复杂，但确实可以通过逐个字符检查的方式来替代 isalnum()，并通过判断每个字符的 ASCII 值是否在字母或数字的范围内来实现。

字符检查：

字母的 ASCII 范围：'A' 到 'Z' 和 'a' 到 'z'。
数字的 ASCII 范围：'0' 到 '9'。
下划线的 ASCII 值为 95（'_'）。
逐字符遍历：

遍历字符串中的每个字符，将其 ASCII 值与上述范围进行对比。


    def is_alnum_or_underscore(s):
        for char in s:
            ascii_value = ord(char)
            if not (ord('A') <= ascii_value <= ord('Z') or
                    ord('a') <= ascii_value <= ord('z') or
                    ord('0') <= ascii_value <= ord('9') or
                    ascii_value == ord('_')):
                return False
        return True

我的水平能想到这个 但还是写不出完整


使用 ASCII 码进行字符判断
通过这种方式，你可以更灵活地控制字符的校验，而不仅仅依赖于 isalnum()，使代码更具可读性和可扩展性。

if (username.isalnum() or '_' in username) 这东西确实没接触过         



### 第二题 最大公约数 素数代码计算和判断 不做

真离谱 大公司校招还有hc吗 不如不做了



题意
小美对 gcd (最大公约数) 很感兴趣，她会询问你t次。

每次询问给出一个大于1的正整数n，你是否找到一个数字 m (2 ≤ m ≤ n)，使得 gcd(n,m)为素数。

输入描述
每个测试文件均包含多组测试数据。第一行输入一个整数 T (1 ≤ T ≤ 100) 代表数据组数，每组测试数据描述如下：

在一行上输入一个整数 n (2 ≤ n ≤ 10^5)代表给定的数字。

输出描述
对于每一组测试数据，在一行上输出一个整数，代表数字m。 如果有多种合法答案，您可以输出任意一种。

示例：
输入：

    2
    114
    15
输出：

    57
    5


思路与代码
题给已经明确的说出 m 的范围是 2 ≤ m ≤ n，因此基本思路就是在[2,n]这个范围内寻找一个数m，满足gcd(n,m)是一个素数。


    public class GCDPrime {
        // 函数：计算两个数的最大公约数（GCD）
        public static int gcd(int a, int b) {
            while (b != 0) {
                int temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }

        // 函数：检查一个数是否为素数
        public static boolean isPrime(int num) {
            if (num <= 1) return false;
            if (num <= 3) return true;
            if (num % 2 == 0 || num % 3 == 0) return false;
            for (int i = 5; i * i <= num; i += 6) {
                if (num % i == 0 || num % (i + 2) == 0) return false;
            }
            return true;
        }

        public static void main(String[] args) {
            Scanner scanner = new Scanner(System.in);
            int T = scanner.nextInt(); 

            ArrayList<Integer> data = new ArrayList<>();
            for (int i = 0; i < T; i++) {
                data.add(scanner.nextInt()); 
            }

            ArrayList<Integer> result = new ArrayList<>();

            for (int n : data) {
                boolean found = false;
                for (int m = 2; m <= n; ++m) {
                    int gcdVal = gcd(n, m); // 计算gcd(n, m)
                    if (isPrime(gcdVal)) { // 检查gcd是否为素数
                        result.add(m);
                        found = true;
                        break; 
                    }
                }
                if (!found) {
                    result.add(-1); 
                }
            }

            for (int res : result) {
                System.out.println(res);
            }

            scanner.close();
        }
    }


这个很明显不知道两个核心代码的数学含义

解题思路：
遍历 m：对于每个 n，我们可以从 m = 2 开始，直到 m = n，计算 gcd(n, m)。一旦发现 gcd(n, m) 为素数，就输出这个 m。
优化：考虑到 gcd(n, m) 的定义，如果我们从 n 的约数开始寻找 m，可以更快找到解。例如，我们可以从 m = n//2 开始往前找，这样可以减少遍历的次数。
素数判断：判断一个数是否为素数时，我们可以使用常规的素数判断方法，比如试除法。



    import math

    def is_prime(x):检查一个数是否为素数
        if x <= 1:
            return False
        if x == 2:
            return True
        if x % 2 == 0:
            return False
        for i in range(3, int(math.sqrt(x)) + 1, 2):这个也夸张 这都什么题？
            if x % i == 0: 试除法 哪里学过吗？
                return False
        return True

    def find_m(n):
        # 从 n//2 开始查找
        for m in range(n//2, n+1):
            g = math.gcd(n, m) ？？？这个计算两个数的最大公约数（GCD）更夸张
            if is_prime(g):检查一个数是否为素数
                return m
        # 理论上会找到答案，因此一般不会到这里
        return None

    # 处理输入和输出
    T = int(input())
    results = []
    for _ in range(T):
        n = int(input())
        results.append(find_m(n))

    # 输出结果
    for result in results:
        print(result)


素数判断太难

简单的就一个计算gcd

在不使用 math 模块的情况下，我们可以手动实现计算两个数的最大公约数（GCD）的方法。通常使用的算法是 欧几里得算法 (Euclidean algorithm)，其基本思想是：

    如果 b 为 0，那么 GCD(a, b) = a。
    否则，GCD(a, b) = GCD(b, a % b)，不断重复这个过程，直到 b 为 0。


欧几里得算法的实现：
以下是使用递归和迭代两种方式实现欧几里得算法的示例。

递归实现：还是这种明了

    def gcd(a, b):
        if b == 0:
            return a
        else:
            return gcd(b, a % b)
迭代实现：

    def gcd(a, b):
        while b != 0:
            a, b = b, a % b
        return a

### 第三题 动两个 极差最小 直接平均值下界，不管边界条件 能狗出来就行



题意
小美有一个长度为 n 的数组，每次操作可以选择两个下标i和 j，将 ai 减去 1，将 aj 加上 1。小美想知道最少需要多少次操作，可以使数组极差最小。

数组的极差为数组中最大值和最小值的差。

输入描述
第一行输入一个整数 n (2 ≤  n ≤ 10^5)代表数组的长度。

第二行输入几 个整数 a1,a2,...,an (1 ≤ ai ≤ 10^9) 代表数组的元素。

输出描述
在一行上输出一个整数，表示最少需要多少次操作。

示例：
输入：

    5
    1 2 3 4 5
输出：

    3
说明：

三次操作分别为 (a1,a5), (a2,a5), (a1,a4)。最终数组为[3,3,3,3,3]，极差为0。


这种太多考虑的没办法 直接死机 没思路

回溯找出所有？        
dp找出最优 怎么dp?????        



思路与代码
这个问题的核心是要通过一系列增减操作来使数组中的最大值和最小值尽可能接近，从而最小化数组的极差。这可以通过计算数组中每个元素与数组平均值之间的差异来完成。

要实现目标，我们应考虑将所有元素调整到一个共同的目标值上，这个目标值最接近整个数组的平均值。由于每次操作是将一个元素减去 1，另一个元素加上 1，这意味着数组的总和在操作前后保持不变。因此，最佳策略是尝试使所有元素达到数组总和除以数组长度的结果（向下取整的结果）？？？？，即平均值。

ok 思路试所有元素达到均值 怎么保证？一次变两个，每次一个个大于小于遍历？或者说先看第一个差值 再遍历找合适的第二个？


    long avg = sum / n;  // 计算平均值（向下取整）
    long extra = sum % n;  // 计算余数，尽管这个变量在此代码中未使用

    // 计算需要操作的最小次数
    long minMoves = 0;
    long need = 0;
    for (int i = 0; i < n; i++) {
        need += a[i] - avg;  // 更新差值累计
        minMoves = Math.max(minMoves, Math.abs(need));  // 更新最大操作次数
    }


很6 但为什么是向下取整 而不是向上？


gemini

    def min_diff(nums):
        n = len(nums)
        nums.sort()
        avg = sum(nums) // n

        # 计算每个元素需要移动的距离
        moves = 0
        for num in nums:
            moves += abs(num - avg)

        return moves // 2  # 因为每次操作会同时改变两个元素，所以总操作次数除以2

    # 示例
    nums = [1, 2, 3, 4, 5]
    result = min_diff(nums)
    print(result)  # 输出：3


为什么这样可行？
平均值作为目标： 将所有元素向平均值靠拢，可以有效缩小极差。
移动距离： 移动距离的总和代表了调整所有元素到目标状态所需的最小操作次数。
除以2的原因： 每次操作会同时改变两个元素，所以总操作次数需要除以2。
优化与拓展
大数处理： 如果数组元素非常大，可以使用更适合大数运算的数据类型或算法。
特殊情况： 可以考虑数组中元素全相等或只有两个不同元素等特殊情况，进行优化。
其他操作： 如果允许更复杂的操作，可以探索更高级的算法。
总结
通过将数组元素向平均值靠拢，并计算每个元素需要移动的距离，我们能有效地求解出最小化数组极差所需的最少操作次数。


也可以 就算不能全a







# 深信服 事后只会写第二题
只知道 dfs深度有限搜索，动态规划         
不知道回溯法      
我理解就是可以回退 然后找出所有可能        
这和dfs不就是一样吗？            



## 第一题
用dp理不清逻辑，别人也有写出部分的        
牛客说用回溯法？能写出大部分           

类似lc 44题



1.吃豆子，我用两个指针和count计数，不是星号就一起前进，是星号就跳过匹配的豆子，然后星号在末尾就退出，结果这题就过了一半左右不知道为啥。
2.魔法数字，用dp处理k之前的和k之后的，结果也就过了一半
3.疲劳度算的不太对，也没时间处理输入输出的，结果没提交，直接做填空题了

第一题他的思路确实简单 但是要是涉及dp我直接懵了第一题





## 第二题 

    class Solution:
        def twoSum(self, n,k,num):
            dp = [0] * (n+1)
            for i in range(1,n+1):
                if i<k :
                    dp[i]=num[i-1]
                else:
                    dp[i] = max(dp[i-1], dp[i-k]+num[i-1])
            return dp[n]
    print(Solution().twoSum(5,2,[3,2,5,10,7]))


根据牛客别人的说法，竟然确实能硬狗出来 可能不能百分百通过        
牛客提示 dp 然后分情况 对k分情况    
自己想就是 先写出状态转移 硬确定 max分法，直接就设置dp[i-1]为前 i-1的最大


第二题可能存在负数的情况，所以dp条件我设置的是dp[i] = Max[当前的, dp[i-1]，dp[i-k]+当前的]，这样就从过90变成过100了   


吃豆子我用栈写的，过了78%，真不知道卡在哪里了     
1
回复
分享
发布于 08-18 21:30
北京
来自iOS客户端

躺平了777

回复
双指针也是a了78     
1
回复
发布于 昨天 13:27
湖南

白面神君不白面

回复
先切割字符串，再用的set，78   

这个set好像有点牛逼？













## 第三题据说回溯

我的笔试一共有四道算法。第一道是01背包，算是签到题吧，除了描述之外也没有改别的条件，有刷过dp的同学应该问题不大。这也是笔试传统了，第一道题通常难度不会太大，大家不用太过于担心。第二道是带权图的最短路径，在acm模式下图论的题目比较困难的就是构建了，但是只要耐心读懂题目，构建出邻接表，dfs/bfs即可破解。第三、第四道分别是任务处理和汉诺塔，这里不展开讲了。


可以留意到，多道算法题的解题思路大概率是不重复的，`dp、图论、回溯、二分、贪心、栈、堆、树`都有可能考察到，所以对于如何准备笔试，我总结以下这几点：

1、对于多类算法，先广度优先地学习，每种算法都简单过一遍，能用这些算法解决easy题，对每个算法有基础的概念之后，再深入学习某一类算法；

2、算法是日积月累的，培养一天刷1～2道题的习惯

3、算是我总结的偷机小技巧，在时间紧迫下，`链表和树可以设为优先级较低的类型`，因为结构的特殊，acm模式很少会出链表和树相关的题目，当然这并不绝对，仅对于时间紧急情况。


2、不用恐惧手撕，手撕通常来说是比笔试简单的，如果笔试能a出来题目，手撕更不是问题了，我面试过程的唯一一道手撕是LRU，有刷算法的同学应该知道这不是一道难题；



LRU-least recently used-最近最少使用算法，是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据。LRU常用语缓存系统的淘汰策略。


4.Redis LRU算法实现

分析Redis LRU实现之前，我们先了解一下Redis缓存淘汰策略。

当Redis内存超出物理内存限制时，内存会频繁的磁盘swap区交换数据，而交换会导致redis对外服务性能的急剧下降，这在生产环境是不允许的。说得更明白些，在生产环境是不允许交换行为的，通过设置maxmemory可限制内存超过期望大小。









## 回溯法
回溯法（Backtracking）是一种通过探索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化来撤销上一步或上几步的计算，即通过“回溯”来尝试其他的候选解。回溯法通常用于解决组合问题、排列问题、子集问题、图的着色问题、旅行商问题（TSP）等。

例子：解决八皇后问题
八皇后问题是一个经典的问题，要求在一个8x8的`棋盘上放置八个皇后，使得她们互不攻击，即任意两个皇后都不在同一行、同一列或同一对角线上`。

    解题思路
    初始化：创建一个8x8的棋盘，并初始化一个数组来记录每一列上皇后的位置（即行号）。
    放置皇后：从第一行开始，尝试在每一列放置皇后。
    检查冲突：对于每一个放置的皇后，检查其是否与已放置的皇后冲突（同行、同列、同对角线）。
    回溯：如果当前位置无法放置皇后（即存在冲突），则回溯到上一行，尝试在该行的下一列放置皇后。如果当前行所有列都尝试完毕且无法放置，则继续回溯到上一行。
    成功放置：如果成功地在第8行放置了皇后，则找到了一个解。
    寻找所有解：找到一个解后，回溯到上一行，继续寻找其他可能的解。

    初始化棋盘和列位置数组  
    for 第1行到第8行:  
        for 第1列到第8列:  
            如果 当前位置可以放置皇后:  
                放置皇后  
                if 当前行 == 8:  
                    找到一个解，打印棋盘  
                    回溯（移除当前行的皇后）  
                else:  
                    递归到下一行  
            回溯（尝试当前行的下一列）

通过回溯法，我们可以系统地探索所有可能的放置方式，直到找到所有符合条件的解。这种方法虽然可能需要探索大量的候选解，但它能保证找到`所有解`（如果存在的话）。


    def is_safe(board, row, col):  
        # 检查列  
        for i in range(row):  # 只检查已有的，走过的。
            if board[i] == col:  # 这是什么？ board索引是行 值是列 假设0行1列已有值，当到达1行时检查board 发现 for col in range(n): 的col其实不可用
                return False  
        
        # 检查左上对角线  
        for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)):  # 这些设置得比较巧妙 
            if board[i] == j:  
                return False  
        
        # 检查右上对角线  
        for i, j in zip(range(row-1, -1, -1), range(col+1, len(board))):  
            if board[i] == j:  
                return False  
        
        return True  
    
    def solve_n_queens(n):  # 这个函数大概能看懂
        def backtrack(row, board):  
            if row == n:  
                result = [''.join('Q' if j == col else '.' for j in range(n)) for col in board]  
                print('\n'.join(result))  
                return  
            
            for col in range(n):  
                if is_safe(board, row, col):  
                    board[row] = col  
                    backtrack(row + 1, board)  
                    board[row] = -1  # 回溯，重置当前行皇后的位置  
    
        board = [-1] * n  # [-1, -1, -1, -1, -1, -1, -1, -1]
        backtrack(0, board)  
    
    # 调用函数解决8皇后问题  
    solve_n_queens(8)

在这个代码中，is_safe 函数用于检查在棋盘的 (row, col) 位置放置皇后是否安全。它检查同一列、左上对角线和右上对角线上是否有其他皇后。

solve_n_queens 函数是主函数，它接受一个参数 n，表示棋盘的大小（n x n）。它定义了一个内部函数 backtrack，该函数递归地尝试在每一行放置皇后，并使用 board 列表来跟踪每一行皇后的列位置。如果成功地在第 n 行放置了皇后，则找到了一个解决方案，并将其打印出来。然后，它回溯到上一行，尝试其他可能的列位置。

最后，solve_n_queens(8) 调用用于解决8皇后问题，并打印出所有可能的解决方案。

下面是一个使用Python实现的八皇后问题的具体代码示例。这个示例使用了回溯法来找到所有可能的解决方案，并将每个解决方案打印到控制台上。


    Q.......
    ....Q...
    .......Q
    .....Q..
    ..Q.....
    ......Q.
    .Q......
    ...Q....
    Q.......
    .....Q..
    .......Q
    ..Q.....
    ......Q.
    ...Q....









# 图论？



# 结尾