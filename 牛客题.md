# 笔试 暑期实习 牛客真题 oj在线编程 OJ在线编程常见输入输出练习 acm模式

一般企业会用到以下几个平台：

牛客网：腾讯、美团等大中小厂；
赛码网：360、顺丰、字节和小红书等大中小厂；
其他小平台或自建平台：阿里等
一般企业都是选择前两个比较大的平台作为笔试的合作方，所以后面我会重点对这两个平台下的一些规则进行梳理。

该类在线测试系统也被称为 OJ (Online Judge)，即在线判题系统，是一种在编程竞赛中用来测试参赛程序的在线系统，也可以用于平时练习。关于该系统也有一些专业的术语和规则，如：
判题时经常会出现的评测状态有：


赛制：
OI 赛制：传统的赛制，比赛期间不能看到结果。以最后一次提交为准。
ACM 赛制：比赛时可以看到结果，必须 AC 了这道题目才会计分，会记录AC 这道题的耗时，每次失败的提交会加上 20 分钟的罚时。通过题目数多的排名在前；通过数一样的耗时少排名靠前。
乐多赛制：洛谷网站独创赛制。结合了 OI 赛制和 ACM 赛制的优点，既可以按照题目的测试点分点得分，也不失比赛的刺激。比赛时可以看到结果。对于一道题的得分，计算为（评测得分*0.95^(本题提交次数-1)），最低扣到原来的 70% 为止。
IOI 赛制：最不刺激的赛制，比赛时可以看到结果，计分按照这道题目的


## 输入方法汇总
输入描述：
包含多组测试用例。
对于每组测试用例：
第一行包括2个整数，N ( 1 < = N < = 1000 ) N(1 <= N <= 1000)N(1<=N<=1000)，M ( 0 < = M < = N ∗ ( N − 1 ) / 2 ) M(0 <= M <= N*(N-1)/2)M(0<=M<=N∗(N−1)/2)，代表现有 N NN 个人（用 1 ∼ N 1 \sim N1∼N 编号）和 M MM 组关系；
在接下来的 M MM 行里，每行包括3个整数，a aa，b bb， c cc，如果 c cc 为1，则代表 a aa 跟 b bb 是同乡；如果 c cc 为0，则代表a aa 跟 b bb 不是同乡；
已知1表示小赛本人。

    输入样例：
    3 1
    2 3 1
    5 4
    1 2 1
    3 4 0
    2 5 1
    3 2 1

所以要是我看到这个问题描述，直接就蒙了，我就会误以为，输入跟我没关系，默认每个输入就是一个测试用例，所以上面的输入样例中，是包含两个测试样例的，第1-2行和第3-7行。


    import math
    while 1: # 每一次循环针对一个测试样例
        #每组第一行是N和M 
        nm = list(map(int,input().split(" "))) # 每一个input()函数都针对一行输入
        N = nm[0]
        M = nm[1]
        print(str(N) + ' ' + str(M))
        # 接下来M行，每行a b c
        for i in range(M):
        abc = list(map(int,input().split(" "))) # 这里就针对除第一行输入外的其他行的输入
        a = abc[0]
        b = abc[1]
        c = abc[2]
        print(str(a) + ' ' + str(b) + ' ' + str(c))


1.2 各种输入输出的情况总结
python 语言中的输入一般使用 input() 或 sys.stdin.readline，一般使用前者即可，使用 print() 进行输出。

1.2.1 单个输入，单个输出

    input = int(input())
    output = input
    print(str(output))

1.2.2 单行多个输入，单行多个输出，空格分割（多行输入，每一行是一个测试样例）

    inputs = list(map(int, input().split(" ")))
    m, n = inputs[0], input[1]
    print(str(m), str(n))

1.2.3 多个测试案例，每个测试案例多行

    while 1:
        nm = list(map(int,input().split(" ")))
        N = nm[0]
        M = nm[1]
        print(str(n)+' '+str(m))
        for i in range(m):
            abc = list(map(int, input().split(" ")))
            a, b, c = abc[0], abc[1], abc[2]
            print(str(a)+' '+str(b)+' '+str(c))


牛客网建议使用 sys.stdin.readline() 获取输入，使用 print() 进行输出。
输入用空格隔开，如果要用 , 隔开，使用 .split(",")

2.1 多行输入，每一行是一个测试样例

    import sys 
    for line in sys.stdin:
        a = line.split()
        print(int(a[0]) + int(a[1]))

2.2 多个测试用例，每个测试用例有多行
输入包含多组测试用例。对于每组测试用例：第一行包含两个整数N和M，在接下来的M行内，每行包括3个整数。要求按照输入格式输出。

    import sys
    for line in sys.stdin:
        n, m = map(int, line.strip().split())
        print(n, m)
        for i in range(m):
            for line in sys.stdin:
                a, b, c = map(int, line.strip().split())
                print(a, b, c)5861/article/details/131903084















## 练习1 循环行读取 for line in sys.stdin 一次读完所有
输出描述：
输出a+b的结果
示例1

    输入例子：
    1 5
    10 20
    输出例子：
    6
    30
解答

    import sys

    for line in sys.stdin: 循环行读取，应该是被读取成一个iterate了 列表还是其他什么结构位置 应该就是next输出 或者是yield
        a = line.split() 行读取 切分空格 列表返回
        print(int(a[0]) + int(a[1]))


## 练习2 按行读取 input()
输出描述：
输出a+b的结果
示例1

    输入例子：
    2
    1 5
    10 20
    输出例子：
    6
    30

答案

    import sys
    
    n = int(input())
    for _ in range(n):
        ls = list(map(int, input().split()))
        print(ls[0] + ls[1])



## 练习3 
输出描述：
输出一行排序后的字符串，空格隔开，无结尾空格
示例1

    输入例子：
    5
    c d a bb e
    输出例子：
    a bb c d e

## 练习4 map直接用于整个list 而且返回值需要再转回list。int直接用不需要括号int()
    for line in sys.stdin:
        a = line.split()
        b = list(map(int, a))
        print(sum(b))

加括号会导致       
Exception has occurred: TypeError
'int' object is not callable
  File "C:\Users\13162\Desktop\工作\多模\leetcode\test.py", line 25, in <module>
    b = list(map(int(), a))
        ^^^^^^^^^^^^^^^^^^^
TypeError: 'int' object is not callable


b = list(map(int, "1"))       
也可以单个直接用 当成列表处理 好像之前有个函数也是这种逻辑         
[1]

# oppo真题
## 第一题 n, m, k = map(int, input().split())
题意：给你 x, y, k 三个正整数，每次可以选择以下操作之一

    x = x - 1
    x = x / k 当且仅当 x % k == 0
问你将 x 变为 y 的最小操作次数。

输入：

三个正整数，

输出

一行一个正整数，表示最小操作次数

样例

输入：

10 4 2

输出

2

思路与代码   
贪心，若  x % k != 0 ，将 x 减少到能整除为止，只到不能整除且大于等于 y ，然后操作1即可。

n, m, k = map(int, input().split())

竟然可以这样


    def solve() -> None:
        n, m, k = map(int, input().split())
        if k == 1:
            print(m - n)
            return
        ans = 0
        
        while n != m:
            if n // k >= m:
                ans += n % k 这个地方太巧妙 不能说简单吧 
                n //= k 题目只给/ - % 竟然能联想到用 // 来减少运算
            else:
                n -= 1 
            ans += 1
        print(ans)    

    if __name__ == '__main__':
        solve()


按照 10 1 3的例子 我肯定会进入else 但是这个方法进竟然没进入


写得比较巧妙 加大理解难度



## 第二题 counter。 for k, v in cnta.items(), from collections import Counter
题意
小O有一个字符串 s，她希望重新排列这个字符串，并改变字符的大小写，使得新的字符串包含尽可能多的字符串 a 或者字符串 b 。请问小O最多能包含多少个子串 a 和 b ， 如果字符串t可以通过从字符串s的开头删除若干(可能为零或全部)字符以及字符串 s 的结尾删除若干(可能为零或全部)字符得到，则字符串 t 是字符串 s 的子串。

输入：

三行三个字符串，s, a, b 其中 a和b开头均为大写，其余均为小写

输出：

包含的子串个数

样例

输入：

    abcdefg
    Abc
    Fge
输出：

2


文字太多

由于 a 和 b 的首字母大写，所有不存在重叠，那么考虑贪心，枚举有多少个 a ,然后计算剩下的字符能组成多少个 b，取最大值即可

题解看不懂

    def solve() -> None:
        s = input()
        a = input()
        b = input()
        s = [x.lower() for x in s]
        a = [x.lower() for x in a]
        b = [x.lower() for x in b]
        cnts = Counter(s)
        cnta = Counter(a)
        cntb = Counter(b)
        ans = 0
        for i in range(len(s)+1):
            ok = True
            for k, v in cnta.items():
                if cnts[k] < i * v:
                    ok = False
            if ok:
                now = len(s)
                for k, v in cntb.items():
                    now = min(now, (cnts[k] - i * cnta[k]) // v)
                ans = max(ans, i + now)
        print(ans)

    if __name__ == '__main__':
        solve()

还是比较难的



这他妈还比较简单？ 两个for循环 一个min中带有// 还有一个max

true false循环设置 以及ok定义完全不知道在干什么

这三行代码使用 Counter 计算每个字符在字符串 s、a 和 b 中出现的频率。cnts、cnta 和 cntb 是三个字典，分别记录了字符及其出现次数。

ok 被用来检查在 s 中是否有足够的字符来满足 i 个字符串 a。

不要求顺序吗


for k, v in cnta.items(): 检查 cnts 中每个字符是否有足够的数量来满足 i 个 a 字符串的需求。   
如果满足条件，计算剩余字符能组成多少个 b 字符串，并更新最大值 ans。    
ans = max(ans, i + now): 通过比较当前计算的值和之前的最大值来更新 ans。   

这段代码的目的是从三个字符串 s、a 和 b 中计算一个最大值 ans。这个值表示你可以从字符串 s 中提取出尽可能多的字符串 a，然后用剩下的字符构造尽可能多的字符串 b。最终，ans 是这些字符串 a 和 b 组合的最大值。


确实牛逼

小O有一个字符串 s，她希望重新排列这个字符串，并改变字符的大小写，使得新的字符串包含尽可能多的字符串 a 或者字符串 b 。请问小O最多能包含多少个子串 a 和 b ， 如果字符串t可以通过从字符串s的开头删除若干(可能为零或全部)字符以及字符串 s 的结尾删除若干(可能为零或全部)字符得到，则字符串 t 是字符串 s 的子串。

题意好像比较矛盾


    now = len(s)
    for k, v in cntb.items():
        now = min(now, (cnts[k] - i * cnta[k]) // v)

如果满足条件，计算剩余字符能组成多少个 b 字符串，并更新最大值 ans。

整个下来挺绕 边界问题竟然被倒逼处理这么好

// v 不太懂是为什么

now = min(now, (cnts[k] - i * cnta[k]) // v)

这句代码 now = min(now, (cnts[k] - i * cnta[k]) // v) 的作用是计算在当前情况下，字符 k 能够满足的最大数量，并更新 now 为其最小值。它是用于确定在 i 个 a 组成的字符串后，剩下的字符能组成的 b 字符串的数量。


// v 是为了计算在剩余字符中，能够组成多少个 b 中需要的字符 k。即通过整数除法确定剩余的字符数量除以每个 b 字符串所需的字符数 v，从而得到可以组成的 b 字符串的数量。

假设我剩下 5个，v=5，那么//v得到1个？

ChatGPT 说：
ChatGPT
是的，正如你所理解的，如果剩下 5 个字符，而每个 b 字符串需要 5 个这样的字符，那么 5 // 5 的结果是 1。这个结果表示，在剩下的字符中，你最多可以组成 1 个 b 字符串。

在这段代码中，// v 用来确定你能用剩余的字符来组成多少个 b 字符串。这里的逻辑是将剩余的字符数除以每个 b 字符串需要的字符数，从而确定最多可以组成多少个 b 字符串。


原来如此





## 第三题

题意
给你一颗树，包含 n 个节点和 n-1 条边，你可以在树中选两个节点进行连无向边，要求连边后的无向图是二分图，问你能连接的最多的边的个数。

输入：

一行一个整数 n, 接下来 n-1 行输入树的边

输出：

能增加的最多的边的条数

样例

输入：

    4
    1 2
    2 3
    3 4
输出：

2


一看就看不懂

本次比试难度适中，没有特别刁钻的题目。第一题简单的贪心，分析一下不难写出来。第二题也是基础的哈希的应用，难度不大。第三题是经典图论问题，dfs遍历即可，注意不要重复遍历。

这他妈


二分图染色，将节点分为两个集合，那么两个集合的点相互连边，这样可以保证结果仍是二分图。假设两个集合个数为 x, y=n-x , 那么答案为 x*y-(n-1)

二分图の定义

        二分图又叫二部图，是图论中的一种特殊模型。

        假设S=(V,E)是一个无向图。如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边(i,j)所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，就可以称图S为一个二分图。简单来说，就是顶点集V可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。

![alt text](assets_picture/牛客题/image.png)

已经很像数学题了        

这题完全不懂


二分图（Bipartite Graph）是一种特殊的图，其中的节点可以被分成两个独立的集合，使得图中的每条边都连接这两个集合中的一个节点。换句话说，二分图中的节点集合可以被划分成两个互不相交的集合，使得所有的边都只在这两个集合之间连接，而不在同一集合内部连接。

图像示例
考虑一个简单的二分图示例：

图 1

    1      2
    |      |
    3      4
这个图是一个二分图，因为你可以将节点分为两组：

集合 𝑈
={
1
,
4
}
U={1,4}

集合 𝑉
={
2
,
3
}
V={2,3}


{竟然可以当成标题

所有的边都连接这两个集合的一个节点。具体来说：

边 
(
1
,
2
)
(1,2) 连接 
𝑈
U 中的节点 1 和 
𝑉
V 中的节点 2。
边 
(
1
,
3
)
(1,3) 连接 
𝑈
U 中的节点 1 和 
𝑉
V 中的节点 3。
边 
(
2
,
4
)
(2,4) 连接 
𝑉
V 中的节点 2 和 
𝑈
U 中的节点 4。
边 
(
3
,
4
)
(3,4) 连接 
𝑉
V 中的节点 3 和 
𝑈
U 中的节点 4。
你可以看到，这个图没有包含奇数长度的环（例如长度为 3 的环），所以它是一个二分图。


图 2（不是二分图）

    1
    / \
    2 - 3
这个图不是二分图，因为它包含了一个长度为 3 的环（1 → 2 → 3 → 1）。在二分图中，我们无法将其节点分为两个集合，使得每条边都连接不同集合中的节点。


如何判断一个图是否是二分图        
判断一个图是否是二分图的一种常用方法是使用 广度优先搜索（BFS） 或 深度优先搜索（DFS） 来尝试对图进行二分着色。如果在搜索过程中发现两个相邻的节点被着上了相同的颜色，则图不是二分图。




二分图（Bipartite Graph）是一种特殊的图，其中的节点可以被分成两个独立的集合，使得图中的每条边都连接这两个集合中的一个节点。换句话说，二分图中的节点集合可以被划分成两个互不相交的集合，使得所有的边都只在这两个集合之间连接，而不在同一集合内部连接。

二分图的性质
节点划分: 二分图的节点集合可以被划分为两个集合 
𝑈
U 和 
𝑉
V，使得每条边的两个端点分别属于这两个集合中的一个。
无奇环: 一个图是二分图的当且仅当它不包含奇数长度的环（循环）。即，二分图不能包含任何长度为奇数的环。
图的着色: 二分图可以用两种颜色来着色，使得相邻的节点颜色不同。
图像示例
考虑一个简单的二分图示例：

图 1
yaml
复制代码
   1      2
   |      |
   3      4
这个图是一个二分图，因为你可以将节点分为两组：

集合 
𝑈
={
1
,
4
}
U={1,4}
集合 
𝑉
={
2
,
3
}
V={2,3}
所有的边都连接这两个集合的一个节点。具体来说：

边 
(
1
,
2
)
(1,2) 连接 
𝑈
U 中的节点 1 和 
𝑉
V 中的节点 2。
边 
(
1
,
3
)
(1,3) 连接 
𝑈
U 中的节点 1 和 
𝑉
V 中的节点 3。
边 
(
2
,
4
)
(2,4) 连接 
𝑉
V 中的节点 2 和 
𝑈
U 中的节点 4。
边 
(
3
,
4
)
(3,4) 连接 
𝑉
V 中的节点 3 和 
𝑈
U 中的节点 4。
你可以看到，这个图没有包含奇数长度的环（例如长度为 3 的环），所以它是一个二分图。

图 2（不是二分图）
复制代码
   1
  / \
 2 - 3
这个图不是二分图，因为它包含了一个长度为 3 的环（1 → 2 → 3 → 1）。在二分图中，我们无法将其节点分为两个集合，使得每条边都连接不同集合中的节点。

如何判断一个图是否是二分图
判断一个图是否是二分图的一种常用方法是使用 广度优先搜索（BFS） 或 深度优先搜索（DFS） 来尝试对图进行二分着色。如果在搜索过程中发现两个相邻的节点被着上了相同的颜色，则图不是二分图。

示例代码
下面是一个使用 BFS 判断一个图是否是二分图的 Python 代码示例：


    from collections import deque, defaultdict

    def is_bipartite(graph, start):
        color = {}
        queue = deque([start])
        color[start] = 0
        
        while queue:
            node = queue.popleft()
            current_color = color[node]
            
            for neighbor in graph[node]:
                if neighbor not in color:
                    color[neighbor] = 1 - current_color
                    queue.append(neighbor)
                elif color[neighbor] == current_color:
                    return False
        
        return True

    def check_bipartite(graph):
        for node in graph:
            if node not in color:
                if not is_bipartite(graph, node):
                    return False
        return True

    # 图的表示：邻接列表
    graph = {
        1: [2, 3],
        2: [1, 3],
        3: [1, 2]
    }

    color = {}
    print("The graph is bipartite:" if check_bipartite(graph) else "The graph is not bipartite.")
在这个示例中，graph 是一个用邻接列表表示的图。如果图是二分图，程序将输出“图是二分图”；否则，输出“图不是二分图”。


    def solve() -> None:
        n = sint()
        adj = [[] for _ in range(n)]
        for i in range(n - 1):
            x, y = mint()
            adj[x - 1].append(y - 1)
            adj[y - 1].append(x - 1)
        m = 0
        def dfs(u, fa, c):
            nonlocal m
            if not c:
                m += 1
            for v in adj[u]:
                if v != fa:
                    dfs(v, u, not c)
        dfs(0, -1, False)
        print(m * (n - m) - (n - 1))
        

    if __name__ == '__main__':
        solve()


    n = map(int, input().split()) 竟然不行
    adj = [[] for _ in range(n)]
    for i in range(n - 1):
        x, y = map(int, input().split())
        adj[x - 1].append(y - 1)
        adj[y - 1].append(x - 1)


代码挺复杂 但是答案不对       
而且后处理很复杂     

        for v in adj[u]:
            if v != fa:
                dfs(v, u, not c)
    dfs(0, -1, False)
    print(m * (n - m) - (n - 1))

n 表示节点数，树的节点数量为 n。
adj 是一个邻接列表，用于表示树的边。
接下来，读入 n-1 条边，每条边连接两个节点 x 和 y。由于 Python 使用零索引，所以减去 1 来适应零索引的数组。


dfs 函数用于遍历树，并计算满足特定条件的节点数量。
u 是当前节点，fa 是父节点，c 是当前节点的颜色（布尔值）。c 从 False 开始。
如果 c 是 False（即节点 u 的颜色为 False），则增加计数 m。
遍历所有与 u 相邻的节点 v，递归调用 dfs，并切换颜色。


计算结果:


    print(m * (n - m) - (n - 1))
m 代表树的节点被染成 False 颜色的数量。
n - m 是树中被染成 True 颜色的节点数量。
m * (n - m) 计算了 False 节点与 True 节点之间边的数量的期望值。
n - 1 是树中总的边数，因为树有 n-1 条边。
结果是两个集合节点之间的边的数量减去 n - 1。


代码的目的是计算一个树的所有节点被分为两个集合后，这两个集合之间的边数的期望值。具体计算方式是通过对树进行二分颜色处理，统计每种颜色的节点数，然后计算这两个集合之间的边数减去树的总边数（n - 1）。

示例替代输入函数
你可以使用 Python 的内置 input() 函数替代 sint() 和 mint()，例如：


    def sint():
        return int(input().strip())

    def mint():
        return map(int, input().strip().split())

太扯了 辅助了也不懂

什么染色完全不明白

图论占比大吗


## 研发b卷814

本次oppo的机考有些卷子出了之前的原题了，还没投的赶紧投了噢，oppo的招聘持续性没有那么强的！

本次比试难度适中。

第1题打卡题，分析出来可以直接秒。

第2题需要分析要求的特点，根据特性来运算，数据很大不能特别暴力。

第3题的n,m比较小，观察到这个点就会好做了。

### 第一题
打卡

题意
有一个无限大的二维平面，上面有小O的两个机器人 A，B，其坐标分别为 (x1, y1) 和 (x2, y2)，小O现在可以操作任意一个机器人进行移动。

具体的，每次移动，被选择的机器人都可以选择四个方向(“上”，“下”，“左”，“右”，)之一，移动一个距离。

小O想知道，将两个机器人移动至同一个格子，最少需要几次移动。




### 第二题

题意
小O有一个仅包含小写字母的字符串，如果一个字符串某个字母出现次数严格大于其他字母出现次数之和，那么这个字符串就是一个好串。小O想删除字符串中的一些字符，使得剩下的字符串是一个好串，问最少删除多少个字符。

输入描述
在一行上输入一个长度不超过 10^5，且仅包含小写字母的字符串s.

输出描述
在一行上输出一个整数，代表最少删除多少个字符。

示例1：
输入：

aaabcd

输出：

1


还好，能分析


直接字典记录次数 找最大 然后直接数学加减计算， 多加1即可      
count > (total - count - 待减x ) 

直接得到 待减x         

不需要counter 内置函数麻烦


### 第三题 没有任何应用逻辑 只是为了出题而出题 语言不通

题意
小O有一个长度为 n 的数组 a1, a2, ..., an，初始全部元素都是 0。

他可以对数组中的一些区间使用“加一"操作：具体的，如果区间是 [l,r]， 则数组中 al 到 ar 的所有数字的值都会加一。

他想使得数组 a 最终单调不降，请问他最多可以选择多少个区间执行操作，使得a仍然满足单调不降。输入描述：输出描述：

输入描述
第一行输入两个整数 n, m (1 ≤ n, m ≤ 20) 表示数组的元素数量，以及可选的区间个数。

接下来 m 行，第 i 行输入两个整数 li, ri (1 ≤ li ≤ ri ≤ n) 表示第 i 个可选区间为 [li, ri]。

输出描述
在一行上输出一个整数，表示最多可以选择的区间个数。

示例1：
输入：

    5 4
    1 2
    2 3
    3 4
    5 5
输出：

    3
说明：

选择第一、三、四个区间操作即可，数组变为{1,1,1,1,1}，满足单调不降。

示例2：
输入：

    10 5
    1 5
    2 5
    3 9
    4 5
    1 6
输出：

    0



代码能稍微看懂 但是没有逻辑 没有价值


if ((mask & (1 << i)) != 0)



这行代码是位操作的一个常见用法，用于检查一个整数（mask）在特定位（由变量i指定）上的值是否为1。这里逐步解释它的工作原理：

    (1 << i)：这是一个位左移操作。它创建了一个整数，该整数在二进制表示中只有第i位（从右往左数，最右边为第0位）是1，其余位都是0。比如，如果i是2，那么(1 << 2)的结果是4（二进制表示为100）。
    mask & (1 << i)：这是一个位与（AND）操作。它将mask与上面步骤中创建的整数进行位与操作。这个操作的结果是一个新的整数，其每一位都是mask和(1 << i)对应位上值的逻辑与结果。因为(1 << i)除了第i位是1之外其余位都是0，所以这个操作实际上只检查了mask的第i位是否为1。如果mask的第i位是1，那么结果就是那个只有第i位是1的整数（即(1 << i)本身）；如果mask的第i位是0，那么结果就是0。
    if ((mask & (1 << i)) != 0)：这个条件判断语句检查上述位与操作的结果是否不等于0。如果不等于0（即mask的第i位是1），那么条件为真，执行if语句块内的代码。这通常用于遍历一个整数的所有位，并检查每一位的值。
    这种技术广泛用于处理位掩码（bitmask），位掩码是一种使用二进制位来表示一系列布尔值的紧凑方法。每个位可以独立地设置或清除，以表示相应的布尔值（true或false）















# 京东
8.10京东研发岗   
考点分别为：模拟、哈希表/二分查找、贪心+位运算


## 第一题：薯条哥醉酒

![alt text](assets_picture/牛客题/image-1.png)

![alt text](assets_picture/牛客题/image-2.png)

![alt text](assets_picture/牛客题/image-3.png)


![alt text](assets_picture/牛客题/image-4.png)


![alt text](assets_picture/牛客题/image-5.png)


    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]  # 北东南西四个方向
    x, y, dirc = 0, 0, 0  # 定义初始位置,初始前进的方向(北方向)

    s = input()

    for ch in s:
        if ch == 'W':
            x = x + dx[dirc]
            y = y + dy[dirc]
        elif ch == 'A':  # 逆时针旋转90度
            dirc = (dirc - 1 + 4) % 4
        elif ch == 'D':   # 顺时针旋转90度
            dirc = (dirc + 1) % 4

    print(x, y)


这才是人做的

## 第二题：求和对数。 哈希表特殊应用 以key作为 加减结果 的索引


![alt text](assets_picture/牛客题/image-6.png)


样例
输入

    3 4
    1 2 3
输出

    3

![alt text](assets_picture/牛客题/image-7.png)

把值直接当成键记录进去。    
半个counter()

    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    cnts = {}
    for i in range(n):
        if a[i] in cnts:
            cnts[a[i]] += 1
        else:
            cnts[a[i]] = 1
    res = 0
    for i in range(n):
        if k - a[i] in cnts:
            res += cnts[k - a[i]]
    print(res)

## 第三题：区间操作


![alt text](assets_picture/牛客题/image-8.png)


![alt text](assets_picture/牛客题/image-9.png)


样例
输入

    2
    5
    1 1 2 1 1
    5
    1 2 3 4 5
输出

    2
    4


![alt text](assets_picture/牛客题/image-10.png)


没看懂？


    def calc(n):
        cnt = 0
        while n > 0:
            if n & 1:
                n -= 1
            else:
                n //= 2
            cnt += 1
        return cnt

    def solve():
        n = int(input())
        a=list(map(int,input().split()))
        op=[0]*n
        for i in range(n):
            op[i]= calc(a[i])
        res = op[0]
        for i in range(1, n):
            res += max(0, op[i] - op[i - 1])
        print(res)

    t = int(input())
    while t > 0:
        solve()
        t -= 1


calc(n) 函数:

功能：计算将 n 变成 0 所需的步骤数。
逻辑：通过判断 n 是奇数还是偶数来决定操作。如果 n 是奇数，则减去 1；如果是偶数，则除以 2。每次操作都计数，直到 n 变成 0。


solve() 函数:

功能：处理每个测试用例，计算并输出结果。
逻辑：
读取整数 n 和包含 n 个整数的列表 a。
对每个整数计算步骤数，将结果存储在 op 列表中。
计算每个步骤数之间的差异，如果当前值大于前一个值，则累加到 res。

    示例：对于输入 n = 3 和 a = [4, 6, 5]：
    计算步骤数：op = [3, 4, 4]
    差异计算：res = 3 + max(0, 4-3) + max(0, 4-4) = 3 + 1 + 0 = 4




主循环:

功能：处理多个测试用例。
逻辑：读取测试用例数量 t，然后循环调用 solve() 函数处理每个测试用例。
示例：如果 t = 2，会依次处理两个测试用例的输入数据。
整体来说，代码的“ultimate”目标是计算和输出每个测试用例的最终结果，即所有数值的“变换步骤数”之和。

还是nlp牛逼


比如现在有3个数字，操作次数分别为2,3,2

那么其实，我们可以先让其操作2次区间，然后再让其操作1次区间即可得到答案。

那么对于第一个数字，我们是一定要花费来进行操作的，然后我们往后面遍历


这块不懂 操作都可以保持一致？万一一个加一个乘呢？


薯条哥有一个长度为且值都为的数组a。对于这个数组薯条哥每次操作可以选择一个区间，对于上的每一个数薯条哥必须让其加一或者乘二(元素之间操作独立，可以选择一些元素乘二，一些元素加一，但是区间内每个元素都要操作)。


始终是题意得问题 第一句和最后一句一直到最后才读懂


## 0817秋招

第1题属于比较基础的模拟，按题意要求操作即可。

第2题数据范围是1000，可以直接去枚举匹配。

第3题是DAG的dp，整体的推导也没有很多坑，难度也中等。



### 第一题


题意
村子里有一些桩子，从左到右高度依次为1,1+2,1+2+3…，每两颗桩子之间的间隔为1.现在下了一场大雪，但是不知道雪下了多厚，现在给你两个数字，这是雪后某相邻两个桩子在雪面的高度，请你通过这两个数字计算雪的厚度。

输入描述
在一行中输入两个正整数a,b

1≤a<b≤5*10^5

输出描述
在一行中输出一个整数代表雪的厚度。我们可以证明，答案一定存在

示例1：
输入：

8 13
输出：

2
示例2：
输入：

10 15
输出：

0
思路与代码
首先算出两个柱子a, b之间的差值c，

然后就可以还原出下雪前b柱子的高度 ：1 + 2 + 3 + ... + c。

这个高度减去b柱子下雪前的高度就是雪的厚度。

#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

int main()
{
    int a, b;
    cin >> a >> b;
    int c = b - a;
    int sum = (c + 1) * c / 2;
    cout << sum - b;
    return 0;
}

### 第二题

题意
牛牛有一种锯齿状的积木，这种积木比较长，但是每个单位长度的高度是相等的，高度为1或者2。现在牛牛拿出了两块长度分别为n 和 m 的积木，她现在想把这两块积木拼接在一起，即使中间有空隙也没有关系。但是拼接后的积木的高度要不超过 3，请你帮助牛牛计算在满足这个前提下拼接后的积木的长度最短可以是多少。

输入描述
第一行给出两个正整数 n,m，代表第一块和第二块积木的长度 第二行给出 n 个数字代表第一块积木每个单位的高度 第三行给出 m 个数字代表第二块积木每个单位的高度


输出描述
在一行中输出一个正整数代表拼接后积木的最短长度

示例1：
输入：

7 10
2212112
2112112112
输出：

10
示例2：
输入：

3 2
222
22
输出：

5
思路与代码
数据范围很小，直接枚举匹配的起点位置就可以，复杂度为。 这里是固定其中一条字符串，移动另一条来匹配。边界条件容易出错，需要特别注意。

    #include <iostream>
    #include <cstring>
    #include <algorithm>
    using namespace std;

    int main()
    {
        int n, m;
        cin >> n >> m;
        string sn, sm;
        cin >> sn >> sm;

        int res = m + n;
        
        for(int j = - m; j < n; j ++)   //枚举要匹配的起始点
        {
            # 傻逼？ int idxm = j;
            int cnt = 0; //cnt表示两个字符串重叠之后小于等于3的长度
            bool flag = true;
            int idxn = j > 0 ? j: 0;   //sn字符串的匹配起点 有点骚
            
            for(int i = j; i < j + m; i ++)  //sm字符串匹配 还行吧 就是这两行写得乱 nm这种命名就是傻子 还有加减界限
            {
                if(i < 0) continue;
                if(idxn >= n) break;
                if(sn[idxn] - '0' + sm[i - j] - '0' > 3){
                    flag = false;
                    break;
                }
                idxn ++;
                cnt ++;
            }
            if(flag)  res = min(res, m + n - cnt);
        }
        cout << res;
        return 0;
    }

题意比较难以理解 这种题最好有图 有视频         
现在多模态确实还没有那么强          

这个解法倒是不难理解


在Python中，当你看到类似sm[i - j] - '0'的代码时，这实际上是一种将字符（假设是数字字符）转换为整数（int）的常用技巧。在Python中，字符和整数之间不能直接进行算术运算，但字符和字符之间可以进行减法运算，前提是这些字符代表的数字在ASCII码表中是连续的。

具体来说，数字字符（如'0', '1', '2', ..., '9'）在ASCII码表中的值是连续的，'0'的ASCII值是48，'1'的ASCII值是49，依此类推，直到'9'的ASCII值是57。因此，当你从一个数字字符中减去'0'时，你实际上是在从该字符的ASCII值中减去'0'的ASCII值（即48），从而得到该字符所代表的整数值。


### 第三题
题意


![alt text](assets_picture/牛客题/image-17.png)


输出描述如果牛牛回家的方案数大于等于20220201种,请你在第一行输出All roads lead to Home! ，然后在第二行输出回家的方案数对20220201取模的结果。
否则只需要输出一行一个整数，表示牛牛回家的方案数示例：输入：

    3 6 2
    1 2 1
    1 2 1
    1 2 1
    2 3 1
    2 3 1
    2 3 1
输出：9



思路与代码使用一个二维数组 dp 来表示从城市 1 到达城市 i，花费 j 元的路径数。dp[i][j] 表示从城市 1 到城市 i，花费正好为 j 的路径数。转移方程：对于每一条从 vi 到 ui，花费 wi 的边，我们可以进行如下状态转移：dp[ui][j + wi] += dp[vi][j]其中 j + wi 不超过 a。
答案即为 dp[n][a]，表示从城市 1 到城市 n，花费恰好为 a 的路径数。需要注意的是要及时对dp数组取模，一旦中间过程一个答案超过了INF，那么后面由这个点转移过去的答案都超过INF，这里用st数组记录。

    #include <iostream>
    #include <cstring>
    #include <algorithm>
    #include <vector>

    const int INF = 20220201;
    using namespace std;

    int main() {
        int n, m, a;
        cin >> n >> m >> a;

        vector<vector<pair<int, int>>> graph(n + 1); 
        for (int i = 0; i < m; ++i) {
            int vi, ui, wi;
            cin >> vi >> ui >> wi;
            graph[vi].emplace_back(ui, wi);
        }

        vector<vector<int>> dp(n + 1, vector<int>(a + 1, 0));
        vector<vector<bool>> st(n + 1, vector<bool>(a + 1, 0));
        dp[1][0] = 1; 
       
        for (int i = 0; i < a; ++i) {
            for (int v = 1; v <= n; ++v) {
                if (dp[v][i] > 0 || st[v][i]) {  
                    for (auto &[u, w] : graph[v]) {
                        if (i + w <= a) {
                            dp[u][i + w] = (dp[u][i + w] + dp[v][i]) % INF;
                            if(dp[u][i + w] + dp[v][i] >= INF) st[u][i + w] = true;
                            if(st[v][i]) st[u][i + w] = true;
                        }
                    }
                }
            }
        }
        if(st[n][a]) cout << "All roads lead to Home!" << endl;
        cout << dp[n][a] << endl; 
        return 0;
    }

py



    INF = 20220201

    def main():
        import sys
        input = sys.stdin.read
        data = input().split()
        index = 0

        def next_int():
            nonlocal index
            index += 1
            return int(data[index-1])

        n, m, a = next_int(), next_int(), next_int()
        graph = [[] for _ in range(n + 1)]
        for _ in range(m):
            vi, ui, wi = next_int(), next_int(), next_int()
            graph[vi].append((ui, wi))

        dp = [[0] * (a + 1) for _ in range(n + 1)]
        st = [[False] * (a + 1) for _ in range(n + 1)]
        dp[1][0] = 1

        for i in range(a):
            for v in range(1, n + 1):# 好像是通过这个地方保证了两条路连起来
                if dp[v][i] > 0 or st[v][i]: 这里也巧妙 如果没有路径的记录会被跳过。 or st[v][i]仍然没看懂这是要干嘛？就是上条路径如果超了，后续新路径就不开了 不计算了？ 不是要取模吗？？
                不对好像是说 抄了就继续进去，但是如果上条dp没有路 为0 进去有什么意义？ 这里难以验证 没有官方例子使用
                    for u, w in graph[v]:# 好像是通过这个地方保证了两条路连起来。首先第二条路起点是v
                        if i + w <= a: # 
                            dp[u][i + w] = (dp[u][i + w] + dp[v][i]) % INF  #有些巧妙 竟然能保证路是连起来的。 然后第一条路的终点是v 很巧妙 这种字典键值的处理
                            然后 dp设置成二维也很巧妙 保证了将 不同终点 以及 相同终点不同价格 都记下来
                            if dp[u][i + w] + dp[v][i] >= INF:
                                st[u][i + w] = True
                            if st[v][i]:
                                st[u][i + w] = True

        if st[n][a]:
            print("All roads lead to Home!")
        print(dp[n][a])

    if __name__ == "__main__":
        main()

这题根本不简单

照着官方例子走一遍还行
















# 美团


## 第一题：偶数因子
简单

## 第二题：登录密码 ak没有评论不知道是不是真的,基本无评论，群里也常常推荐老题目，主营网站  万诺每个都有评论，主营教学付费

在线测评链接：https://www.sspnote.com/oj/3/342
题目描述
ak机准备登录美团，需要输入密码，ak机忘记了密码，只记得密码可能是字符串中的一个。ak机会按照密码的长度从小到大依次尝试每

个字符串，对于相同长度的字符串，ak机随机尝试，并且相同的密码只会尝试一次。ak机想知道，她最少需要尝试多少次才能登录成功，

最多需要尝试多少次才能登录成功。

ak机不会重新尝试已经尝试过的字符串。成功登录后会立即停止尝试。

![alt text](assets_picture/牛客题/image-11.png)


样例
输入

    4
    ab
    abc
    ab
    ac
    ac
输出

    1 2
样例解释

ak机可能按照 ["ab", "ac", "abc"] 的顺序尝试，第一次尝试成功，也可能按照 ["ac", "ab", "abc"] 的顺序尝试，第二次尝试成功。

ak机在尝试 "ac" 发现不正确后不会继续尝试 "ac"。



## 817万诺 算法五道俩小时
第一题挺麻烦的，就是字符串模拟，用正则就更工程化一点。

第二天题也比较简单，求gcd和prim就好了，接着就是按照题目要求模拟。

第三题需要一些小技巧，分析题目要求的性质也不会很难。


算法岗的1、2、4题为测开、客户端的三道题目

侧开


### 第一题 正则式写法？不做


题意
小美在处理外卖订单的时候，遇到一个任务，他需要判断一个给定的字符串是否符会特定的分类规则。

具体来说，我们需要判断一个字符串是否是一个有效的电子邮件地址、IP 地址或者电话号码。

电子邮件地址的格式为:username@domain.com，其中 username 和 domain 只能包含字母、数字和下划线。
IP 地址的格式为：xxx.xxx.xxx.xxx，其中 xxx 是 0 到 255 之间的整数。
电话号码的格式为：+国家码-区号-号码 ，其中 国家码 和 区号 只能包含数字，号码 可以包含数字和'#’。
输入描述

输入描述
第一行包含数据组数 n。

接下来的 n 行，每一行输入一个需要判断的字符串。

输出描述
对于每一行，输出判断的结果，可能的结果如下:

    如果是有效的电子邮件地址，输出 email。
    如果是有效的 IP 地址，输出 ip。
    如果是有效的电话号码，输出 phone。
    如果都不是，输出invalid。
示例：
输入：

    5
    user@example.com
    192.168.1.1
    +86-10-12345#78
    hello@world
    256.256.256.256
输出：

    email
    ip
    phone
    invalid
    invalid


思路与代码
模拟题，但是逻辑毕竟复杂，可以使用正则表达式来检查字符串是否符合给定的格式：电子邮件地址、IP 地址或电话号码。

    关于正则表达式匹配电子邮件地址、IP地址、电话号码的解释:

    电子邮件地址的正则表达式

    ^：表示字符串的开始。

    [a-zA-Z0-9_]+：匹配一个或多个字母（大小写均可）、数字或下划线。这部分用于匹配电子邮件的 "username" 部分。

    @：字面意义上的 '@' 符号，电子邮件地址的标准部分。

    [a-zA-Z0-9_]+：再次匹配一个或多个字母（大小写均可）、数字或下划线。这部分用于匹配电子邮件的 "domain" 部分。

    \\.com：匹配字面上的 ".com"。点号 (.) 在正则表达式中是一个特殊字符，代表任意字符，所以使用 \\. 来表示字面上的点号。

    $：表示字符串的结束。

    这个正则表达式只匹配以 ".com" 结尾的电子邮件地址，并且 "username" 和 "domain" 部分只能包含字母、数字和下划线。

    IP地址的正则表达式

    该正则表达式确保 IP 地址由四部分组成，每部分是 0 到 255 的整数，四部分之间由点号分隔。

    \d{1,2}：匹配 1 到 2 位的数字（0 到 99）。

    1\d{2}：匹配 100 到 199。

    2[0-4]\d：匹配 200 到 249。

    25[0-5]：匹配 250 到 255。

    ^：表示字符串的开始。

    (\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])：这个分组表达式用于匹配 0 到 255 之间的整数。

    \\.：匹配点号，IP 地址各部分的分隔符。

    $：表示字符串的结束。

    电话号码的正则表达式

    ^：表示字符串的开始。
    \\+：匹配加号 (+)，通常用于国际电话号码的开头。
    \\d+：匹配一个或多个数字，用于国家码。
    -：字面意义上的短划线，用于分隔国家码和区号。
    \\d+：再次匹配一个或多个数字，用于区号。
    -：又一个字面意义上的短划线，用于分隔区号和电话号码。
    [\\d#]+：匹配一个或多个数字或井号 (#)，用于电话号码。
    $：表示字符串的结束。
    这个正则表达式用于匹配国际电话号码，其中号码部分可以包含数字和井号。

我靠 直接正则表达式还写个毛

如果是写普通逻辑还好

第一题挺麻烦的，就是字符串模拟，用正则就更工程化一点。

字符串模拟通常指的是在编程题目中，对字符串的操作或处理进行模拟。这类题目一般要求你模拟某些字符串操作，如插入、删除、替换、反转、查找子串等，或者对字符串进行某种变换和处理。

举个例子：

假设有一道题目要求你模拟一个字符串的变换操作，比如将字符串中的所有元音字母（a, e, i, o, u）替换成数字1，其他字符保持不变。

问题描述：
给定一个字符串，请将其中的元音字母替换成数字1，返回处理后的字符串。

输入："hello world"

输出："h1ll1 w1rld"

解题思路：

遍历字符串的每一个字符。
如果字符是元音字母，替换为数字1。
其余字符保持不变。
将最终的字符串返回。
示例代码（Python）：

    python
    复制代码
    def replace_vowels(s):
        vowels = "aeiouAEIOU"
        result = []
        for char in s:
            if char in vowels:
                result.append('1')
            else:
                result.append(char)
        return ''.join(result)

    # 测试
    input_str = "hello world"
    output_str = replace_vowels(input_str)
    print(output_str)  # 输出："h1ll1 w1rld"
总结：
字符串模拟题目主要考察的是对字符串的操作和处理能力。通常要求熟练使用字符串操作的基本方法和技巧，比如遍历、索引、切片、拼接等。

    def is_valid_email(s):
        if '@' not in s or s.count('@') != 1:
            return False
        username, domain = s.split('@')
        if '.' not in domain or domain.count('.') != 1:
            return False
        domain_name, domain_suffix = domain.split('.')
        
        if (username.isalnum() or '_' in username) and (domain_name.isalnum() or '_' in domain_name) and domain_suffix.isalnum():
            return True
        return False


如果能直接复制确实好

    def is_valid_ip(s):
        parts = s.split('.')
        if len(parts) != 4:
            return False
        for part in parts:
            if not part.isdigit() or not 0 <= int(part) <= 255:
                return False
        return True



    def is_valid_phone(s):
        if not s.startswith('+'):
            return False
        parts = s[1:].split('-')
        if len(parts) != 3:
            return False
        country_code, area_code, number = parts
        if not country_code.isdigit() or not area_code.isdigit():
            return False
        for ch in number:
            if not ch.isdigit() and ch != '#':
                return False
        return True

将 username.isalnum() 转换为二进制处理的方式会显得比较复杂，但确实可以通过逐个字符检查的方式来替代 isalnum()，并通过判断每个字符的 ASCII 值是否在字母或数字的范围内来实现。

字符检查：

字母的 ASCII 范围：'A' 到 'Z' 和 'a' 到 'z'。
数字的 ASCII 范围：'0' 到 '9'。
下划线的 ASCII 值为 95（'_'）。
逐字符遍历：

遍历字符串中的每个字符，将其 ASCII 值与上述范围进行对比。


    def is_alnum_or_underscore(s):
        for char in s:
            ascii_value = ord(char)
            if not (ord('A') <= ascii_value <= ord('Z') or
                    ord('a') <= ascii_value <= ord('z') or
                    ord('0') <= ascii_value <= ord('9') or
                    ascii_value == ord('_')):
                return False
        return True

我的水平能想到这个 但还是写不出完整


使用 ASCII 码进行字符判断
通过这种方式，你可以更灵活地控制字符的校验，而不仅仅依赖于 isalnum()，使代码更具可读性和可扩展性。

if (username.isalnum() or '_' in username) 这东西确实没接触过         



### 第二题 最大公约数 素数代码计算和判断 不做

真离谱 大公司校招还有hc吗 不如不做了



题意
小美对 gcd (最大公约数) 很感兴趣，她会询问你t次。

每次询问给出一个大于1的正整数n，你是否找到一个数字 m (2 ≤ m ≤ n)，使得 gcd(n,m)为素数。

输入描述
每个测试文件均包含多组测试数据。第一行输入一个整数 T (1 ≤ T ≤ 100) 代表数据组数，每组测试数据描述如下：

在一行上输入一个整数 n (2 ≤ n ≤ 10^5)代表给定的数字。

输出描述
对于每一组测试数据，在一行上输出一个整数，代表数字m。 如果有多种合法答案，您可以输出任意一种。

示例：
输入：

    2
    114
    15
输出：

    57
    5


思路与代码
题给已经明确的说出 m 的范围是 2 ≤ m ≤ n，因此基本思路就是在[2,n]这个范围内寻找一个数m，满足gcd(n,m)是一个素数。


    public class GCDPrime {
        // 函数：计算两个数的最大公约数（GCD）
        public static int gcd(int a, int b) {
            while (b != 0) {
                int temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }

        // 函数：检查一个数是否为素数
        public static boolean isPrime(int num) {
            if (num <= 1) return false;
            if (num <= 3) return true;
            if (num % 2 == 0 || num % 3 == 0) return false;
            for (int i = 5; i * i <= num; i += 6) {
                if (num % i == 0 || num % (i + 2) == 0) return false;
            }
            return true;
        }

        public static void main(String[] args) {
            Scanner scanner = new Scanner(System.in);
            int T = scanner.nextInt(); 

            ArrayList<Integer> data = new ArrayList<>();
            for (int i = 0; i < T; i++) {
                data.add(scanner.nextInt()); 
            }

            ArrayList<Integer> result = new ArrayList<>();

            for (int n : data) {
                boolean found = false;
                for (int m = 2; m <= n; ++m) {
                    int gcdVal = gcd(n, m); // 计算gcd(n, m)
                    if (isPrime(gcdVal)) { // 检查gcd是否为素数
                        result.add(m);
                        found = true;
                        break; 
                    }
                }
                if (!found) {
                    result.add(-1); 
                }
            }

            for (int res : result) {
                System.out.println(res);
            }

            scanner.close();
        }
    }


这个很明显不知道两个核心代码的数学含义

解题思路：
遍历 m：对于每个 n，我们可以从 m = 2 开始，直到 m = n，计算 gcd(n, m)。一旦发现 gcd(n, m) 为素数，就输出这个 m。
优化：考虑到 gcd(n, m) 的定义，如果我们从 n 的约数开始寻找 m，可以更快找到解。例如，我们可以从 m = n//2 开始往前找，这样可以减少遍历的次数。
素数判断：判断一个数是否为素数时，我们可以使用常规的素数判断方法，比如试除法。



    import math

    def is_prime(x):检查一个数是否为素数
        if x <= 1:
            return False
        if x == 2:
            return True
        if x % 2 == 0:
            return False
        for i in range(3, int(math.sqrt(x)) + 1, 2):这个也夸张 这都什么题？
            if x % i == 0: 试除法 哪里学过吗？
                return False
        return True

    def find_m(n):
        # 从 n//2 开始查找
        for m in range(n//2, n+1):
            g = math.gcd(n, m) ？？？这个计算两个数的最大公约数（GCD）更夸张
            if is_prime(g):检查一个数是否为素数
                return m
        # 理论上会找到答案，因此一般不会到这里
        return None

    # 处理输入和输出
    T = int(input())
    results = []
    for _ in range(T):
        n = int(input())
        results.append(find_m(n))

    # 输出结果
    for result in results:
        print(result)


素数判断太难

简单的就一个计算gcd

在不使用 math 模块的情况下，我们可以手动实现计算两个数的最大公约数（GCD）的方法。通常使用的算法是 欧几里得算法 (Euclidean algorithm)，其基本思想是：

    如果 b 为 0，那么 GCD(a, b) = a。
    否则，GCD(a, b) = GCD(b, a % b)，不断重复这个过程，直到 b 为 0。


欧几里得算法的实现：
以下是使用递归和迭代两种方式实现欧几里得算法的示例。

递归实现：还是这种明了

    def gcd(a, b):
        if b == 0:
            return a
        else:
            return gcd(b, a % b)
迭代实现：

    def gcd(a, b):
        while b != 0:
            a, b = b, a % b
        return a

### 第三题 动两个 极差最小 直接平均值下界，不管边界条件 能狗出来就行



题意
小美有一个长度为 n 的数组，每次操作可以选择两个下标i和 j，将 ai 减去 1，将 aj 加上 1。小美想知道最少需要多少次操作，可以使数组极差最小。

数组的极差为数组中最大值和最小值的差。

输入描述
第一行输入一个整数 n (2 ≤  n ≤ 10^5)代表数组的长度。

第二行输入几 个整数 a1,a2,...,an (1 ≤ ai ≤ 10^9) 代表数组的元素。

输出描述
在一行上输出一个整数，表示最少需要多少次操作。

示例：
输入：

    5
    1 2 3 4 5
输出：

    3
说明：

三次操作分别为 (a1,a5), (a2,a5), (a1,a4)。最终数组为[3,3,3,3,3]，极差为0。


这种太多考虑的没办法 直接死机 没思路

回溯找出所有？        
dp找出最优 怎么dp?????        



思路与代码
这个问题的核心是要通过一系列增减操作来使数组中的最大值和最小值尽可能接近，从而最小化数组的极差。这可以通过计算数组中每个元素与数组平均值之间的差异来完成。

要实现目标，我们应考虑将所有元素调整到一个共同的目标值上，这个目标值最接近整个数组的平均值。由于每次操作是将一个元素减去 1，另一个元素加上 1，这意味着数组的总和在操作前后保持不变。因此，最佳策略是尝试使所有元素达到数组总和除以数组长度的结果（向下取整的结果）？？？？，即平均值。

ok 思路试所有元素达到均值 怎么保证？一次变两个，每次一个个大于小于遍历？或者说先看第一个差值 再遍历找合适的第二个？


    long avg = sum / n;  // 计算平均值（向下取整）
    long extra = sum % n;  // 计算余数，尽管这个变量在此代码中未使用

    // 计算需要操作的最小次数
    long minMoves = 0;
    long need = 0;
    for (int i = 0; i < n; i++) {
        need += a[i] - avg;  // 更新差值累计
        minMoves = Math.max(minMoves, Math.abs(need));  // 更新最大操作次数
    }


很6 但为什么是向下取整 而不是向上？


gemini

    def min_diff(nums):
        n = len(nums)
        nums.sort()
        avg = sum(nums) // n

        # 计算每个元素需要移动的距离
        moves = 0
        for num in nums:
            moves += abs(num - avg)

        return moves // 2  # 因为每次操作会同时改变两个元素，所以总操作次数除以2

    # 示例
    nums = [1, 2, 3, 4, 5]
    result = min_diff(nums)
    print(result)  # 输出：3


为什么这样可行？
平均值作为目标： 将所有元素向平均值靠拢，可以有效缩小极差。
移动距离： 移动距离的总和代表了调整所有元素到目标状态所需的最小操作次数。
除以2的原因： 每次操作会同时改变两个元素，所以总操作次数需要除以2。
优化与拓展
大数处理： 如果数组元素非常大，可以使用更适合大数运算的数据类型或算法。
特殊情况： 可以考虑数组中元素全相等或只有两个不同元素等特殊情况，进行优化。
其他操作： 如果允许更复杂的操作，可以探索更高级的算法。
总结
通过将数组元素向平均值靠拢，并计算每个元素需要移动的距离，我们能有效地求解出最小化数组极差所需的最少操作次数。


也可以 就算不能全a


## 810
### 第一题 小美的密码
小美准备登录美团，需要输入密码，小美忘记了密码，只记得密码可能是 n个字符串中的一个。小美会按照密码的长度从小到大依次尝试每个字符串，对于相同长度的字符串，小美随机尝试，并且相同的密码只会尝试一次。小美想知道，她最少需要尝试多少次才能登录成功，最多需要尝试多少次才能登录成功。小美不会重新尝试已经尝试过的字符串。成功登录后会立即停止尝试。

输入描述第一行输入一个整数 n(1<=n<=1000)代表密码字符串的个数。第二行输入一个只由小写字母组成的字符串 s(1<=|s|<=1000)代表正确的密码。接下来 n 行，每行输入一个长度不超过 1000的字符串，代表小美记得的密码。

输出描述在一行上输出两个整数，表示最少和最多尝试次数。示例 1输入

    4
    ab
    abc
    ab
    ac
    ac

输出

1 2



    from collections import defaultdict

    n = int(input())
    ans = input()

    pos = defaultdict(set)
    for _ in range(n):
        p = input()
        pos[len(p)].add(p)

    pos = dict(sorted(pos.items()))

    step = 0
    MIN,MAX = -1,-1
    for k,v in pos.items():
        if ans in v:
            MIN =step + 1
            MAX = step + len(v)
        else:
            step += len(v)

    print(MIN, MAX)

很简单 但是答案比我想的更简单

因为有充分利用了键值 和 集合

### 第二题 小美的数组删除

小美有一个长度为 n 的数组 a1,a2,....,an ，他可以对数组进行如下操作：● 删除第一个元素 a1，同时数组的长度减一，花费为 x。● 删除整个数组，花费为 k*MEX(a) （其中 MEX(a) 表示 a 中未出现过的最小非负整数。例如 [0,1,2,4] 的 MEX 为 3 ）。小美想知道将 a 数组全部清空的最小代价是多少，请你帮帮他吧。

输入描述

每个测试文件均包含多组测试数据。第一行输入一个整数 T(1<=T<=1000) 代表数据组数，每组测试数据描述如下：第一行输入三个正整数 n,k,x(1<=n<=2*10^5, 1<=k,x<=10^9) 代表数组中的元素数量、删除整个数组的花费系数、删除单个元素的花费。第二行输入 n 个整数 a1,a2,....,an(0<=ai<=n)，表示数组元素。除此之外，保证所有的 n 之和不超过 2*10^5。


输出描述

对于每一组测试数据，在一行上输出一个整数表示将数组中所有元素全部删除的最小花费。


输入

1
6 3 3
4 5 2 3 1 0

输出15

说明若不执行操作一就全部删除，MEX{4,5,2,3,1,0} = 6，花费 18 ；
若执行一次操作一后全部删除，MEX{5,2,3,1,0} = 4，花费 3+12；
若执行两次操作一后全部删除，MEX{2,3,1,0} = 4，花费 6+12 ；
若执行三次操作一后全部删除，MEX{3,1,0} = 2，花费 9+6 ；
若执行四次操作一后全部删除，MEX{1,0} = 2，花费 12+6 ；
若执行五次操作一后全部删除，MEX{0} = 1，花费 15+3；
若执行六次操作一，MEX{} = 0，花费 18；

太绕了

直接就是遍历 min 对着示例输出

思路和代码

动态规划+维护动态最小未出现的整数。f[i]表示从i往后考虑的最小花费，选择就是选择第一个元素或者直接删除后续所有的元素。

对于删除后续所有的元素的选项，我们必须要直到MEX是多少，我们可以用在更新dp的过程中，用一个suffix不断地更新当前的最小未出现的整数。虽然这里出现了两层循环的嵌套，但是并不会重置参数，因此复杂度是O(n).

第二题需要一点小技巧，包装在更新过程中可以线性的维护核心的值即可，难度也不算很大。



    from math import inf

    T = int(input())
    for _ in range(T):
        n,k,x = map(int, input().split())
        A = [int(c) for c in input().split()]
        dp = [inf]*(n+1)
        dp[n] = 0
        vst = set()
        suffix_MEX = 0
        for i in range(n-1,-1,-1):
            vst.add(A[i])
            while suffix_MEX in vst:
                suffix_MEX += 1
            dp[i] = min(dp[i+1]+x, k*suffix_MEX)
        print(dp[0])

从后往前算 方便 suffix_MEX  同时 dp设置也很巧妙

而且 suffix_MEX 不会重复计算

保证 o(n)解决？


### 第三题 小美的彩带

小美的彩带是由一条长度为 n 的彩带一直无限循环得到的，彩带的每一个位置都有一个颜色，用 ai 表示。因此当 i>n 时，ai = ai-n  。小美每次会从左往后或从右往左剪一段长度为 x 的彩带，她想知道她每次剪下来的彩带有多少种颜色。

输入描述

第一行输入两个整数 n,q(1<=n,q<=2*10^5) 代表彩带长度、剪彩带次数。第二行输入 n 个整数 a1,a2,...,an(1<=ai<=10^9) 代表彩带每一个位置的颜色。此后 q 行，每行输入一个字符 c 和一个整数 x(1<=x<=10^9; c∈L,R) 代表裁剪方向和裁剪长度，其中 'L' 说明从左往右剪， 'R' 说明从右往左剪 。


输出描述

对于每一次裁剪彩带，在一行上输出一个整数代表颜色数量。


输入

    6 3
    1 1 4 5 1 4
    L 2
    L 3
    R 12
输出

    1
    3
    3

说明第一次剪彩带，剪下来的是 [1,1] ，有 {1} 这 1 种颜色；
第二次剪彩带，剪下来的是 [4,5,1] ，有 {1,4,5} 这 3 种颜色；
第三次剪彩带，剪下来的是 [1,1,4,5,1,4,1,1,4,5,1,4] ，有 {1,4,5} 这 3 种颜色。


题目看不懂 放弃

表达不清晰 就是得照着示例写代码


直接for循环用set解决


太复杂了

    MAXN = 2000007

    a = [0] * MAXN
    ans = [0] * MAXN
    hsh = [0] * MAXN
    vis = [0] * MAXN
    c = [0] * MAXN

    def lowbit(x):
        return x & -x

    def update(x, k):
        while x < MAXN:
            c[x] += k
            x += lowbit(x)

    def getsum(x):
        sum = 0
        while x > 0:
            sum += c[x]
            x -= lowbit(x)
        return sum

    def main():
        n, q = map(int, input().split())
        queries = []

        for i in range(1, n + 1):
            a[i] = int(input())
            hsh[i] = a[i]

        hsh = sorted(set(hsh[1:n+1]))  # 直接去重排序
        idx_map = {v: i + 1 for i, v in enumerate(hsh)}  # 值到索引的映射

        for i in range(1, n + 1):
            a[i] = a[n + i] = idx_map[a[i]]  # 双倍数组

        nl, nr = 1, n * 2

        for i in range(q):
            direction, x = input().split()
            x = min(int(x), n)
            if direction == 'L':
                queries.append((nl, nl + x - 1, i))
                nl += x
                if nl > n:
                    nl -= n
            else:
                queries.append((nr - x + 1, nr, i))
                nr -= x
                if nr <= n:
                    nr += n

        queries.sort(key=lambda q: q[1])

        cur = 1
        for l, r, i in queries:
            while cur <= r:
                if vis[a[cur]]:
                    update(vis[a[cur]], -1)
                update(cur, 1)
                vis[a[cur]] = cur
                cur += 1
            ans[i] = getsum(r) - getsum(l - 1)

        for i in range(q):
            print(ans[i])

    if __name__ == "__main__":
        main()

lowbit(x)：计算x的二进制表示中最低位的1对应的数值。这个函数用于实现树状数组（Fenwick Tree）的索引更新。

    def lowbit(x):
        return x & -x


    def update(x, k):
        while x < MAXN:
            c[x] += k
            x += lowbit(x)
update(x, k)：更新树状数组c，将值k加到位置x及其影响的后续位置。用于维护区间和信息。


    def getsum(x):
        sum = 0
        while x > 0:
            sum += c[x]
            x -= lowbit(x)
        return sum
getsum(x)：计算从1到x之间的前缀和。通过树状数组快速计算某一区间的和。

前缀和的定义
对于一个给定的数列A，他的前缀和数中 S 中 S[ i ] 表示从第一个元素到第 i 个元素的总和。

如下图：绿色区域的和就是前缀和数组中的 S [ 6 ]。


![alt text](assets_picture/牛客题/image-18.png)


2. 一维前缀和
2.1 计算公式
前缀和数组的每一项是可以通过原序列以递推的方式推出来的，递推公式就是：S[ i ] = S[  i - 1 ] + A[ i ]。S[  i - 1 ] 表示前 i - 1 个元素的和，在这基础上加上 A[ i ]，就得到了前 i 个元素的和 S [ i ]。

2.2 用途
一维前缀和的主要用途：求一个序列中某一段区间中所有元素的和。有如下例子：

有一个长度为 n 的整数序列。

接下来输入 m 个询问，每个询问输入一对 l，r。

对于每个询问，输出原序列中第 l 个数到第 r 个数的和。


queries：用于存储每个查询的信息。


    for i in range(1, n + 1):
        a[i] = int(input())
        hsh[i] = a[i]
读取n个整数，并存入数组a和hsh中。hsh数组用于后续去重和排序。


    hsh = sorted(set(hsh[1:n+1]))
    idx_map = {v: i + 1 for i, v in enumerate(hsh)}
hsh：通过set去重，并sorted排序，得到唯一且有序的元素列表。
idx_map：将这些唯一元素映射到它们对应的索引，用于压缩原始数据（即将原始值映射到一个较小的范围内）。


    for i in range(1, n + 1):
        a[i] = a[n + i] = idx_map[a[i]]
使用idx_map对数组a中的元素进行值压缩，并将其双倍复制到a的后半部分，用于处理区间查询时的循环逻辑。

这种字典中查字典的行为真太乱了


   queries.sort(key=lambda q: q[1])
将所有查询按照右边界r从小到大排序。这样可以在处理时高效地更新区间和。

对每个查询进行处理。遍历从cur到r的范围，更新树状数组，并记录每个元素最后出现的位置。
计算当前查询区间的和，存储在ans数组中


核心逻辑
树状数组：用于快速维护和查询区间和，通过update和getsum实现。
查询处理：根据左右边界的不同移动方向，调整区间位置，最后通过排序和树状数组的高效计算，得出结果。
总结
这段代码通过压缩数据、使用树状数组和双倍数组技巧，有效处理了一系列区间查询。优化后的代码简洁明了，保留了关键的算法思路，同时去除了冗余和复杂的部分。


a[i] = a[n + i] = idx_map[a[i]] 这行代码中的两个等号实现了链式赋值的操作。

链式赋值的原理
链式赋值的含义是从右到左依次进行赋值。具体到这行代码，操作步骤如下：

最右侧的表达式计算：首先计算右侧的表达式，即 idx_map[a[i]]，得到一个值。

赋值给最左侧的变量：将这个值赋给 a[n + i]。

继续赋值给左侧的另一个变量：接着将这个值赋给 a[i]。

具体作用
所以，这行代码的作用是：

先计算 idx_map[a[i]]，这个表达式将 a[i] 的值映射到一个新的索引值。
然后，将这个新索引值同时赋值给 a[i] 和 a[n + i]。


假设：

n = 5
i = 2
idx_map[a[i]] = 10
那么执行 a[i] = a[n + i] = idx_map[a[i]] 后，a[2] 和 a[7] 都会被赋值为 10。

作用
这个操作的主要目的是将数组 a 中第 i 个位置的值更新为 idx_map 映射后的新值，并且同时更新数组 a 中第 n + i 个位置的值为相同的值。这在算法中可能用于构造双倍数组或进行数据压缩的处理。

x & -x 是一个常见的二进制运算操作，用于提取整数 x 的二进制表示中最低位的1所对应的值。


负数的补码表示：

在计算机中，负数是以补码形式存储的。对于一个整数 x，它的负数 -x 可以通过取反并加1得到。
例如，如果 x = 6，它的二进制是 0110。-x 的二进制表示是 1010。


按位与运算：

& 是按位与运算符，对应位置的两个二进制位都为1时，结果为1，否则为0。
计算 x & -x：

x & -x 会将 x 的最低位的1保留下来，其他位都变为0。


例子 1：x = 6
x 的二进制表示是 0110。
-x 的二进制表示是 1010。
x & -x 的结果：
plaintext
复制代码
0110   (x)
&
1010   (-x)
----
0010   (结果)
所以，x & -x = 2，即 0010。
例子 2：x = 12
x 的二进制表示是 1100。
-x 的二进制表示是 0100。
x & -x 的结果：
plaintext
复制代码
1100   (x)
&
0100   (-x)
----
0100   (结果)
所以，x & -x = 4，即 0100。



用途
x & -x 在算法中有多种用途，其中最常见的是：

提取最低位的1：在树状数组（Fenwick Tree）中，x & -x 用来找到一个位置的最低位1，常用于快速定位和更新区间。
检查是否为2的幂：如果 x 是2的幂，那么它只有一个二进制位为1，x & -x 的结果等于 x 本身。
总结
x & -x 是一个简单而有效的操作，可以快速提取整数的最低位1所在的值，广泛应用于各种算法和位运算操作中。


离谱



# 深信服 事后只会写第二题
只知道 dfs深度有限搜索，动态规划         
不知道回溯法      
我理解就是可以回退 然后找出所有可能        
这和dfs不就是一样吗？            



## 第一题
用dp理不清逻辑，别人也有写出部分的        
牛客说用回溯法？能写出大部分           

类似lc 44题



1.吃豆子，我用两个指针和count计数，不是星号就一起前进，是星号就跳过匹配的豆子，然后星号在末尾就退出，结果这题就过了一半左右不知道为啥。
2.魔法数字，用dp处理k之前的和k之后的，结果也就过了一半
3.疲劳度算的不太对，也没时间处理输入输出的，结果没提交，直接做填空题了

第一题他的思路确实简单 但是要是涉及dp我直接懵了第一题





## 第二题 

    class Solution:
        def twoSum(self, n,k,num):
            dp = [0] * (n+1)
            for i in range(1,n+1):
                if i<k :
                    dp[i]=num[i-1]
                else:
                    dp[i] = max(dp[i-1], dp[i-k]+num[i-1])
            return dp[n]
    print(Solution().twoSum(5,2,[3,2,5,10,7]))


根据牛客别人的说法，竟然确实能硬狗出来 可能不能百分百通过        
牛客提示 dp 然后分情况 对k分情况    
自己想就是 先写出状态转移 硬确定 max分法，直接就设置dp[i-1]为前 i-1的最大


第二题可能存在负数的情况，所以dp条件我设置的是dp[i] = Max[当前的, dp[i-1]，dp[i-k]+当前的]，这样就从过90变成过100了   


吃豆子我用栈写的，过了78%，真不知道卡在哪里了     
1
回复
分享
发布于 08-18 21:30
北京
来自iOS客户端

躺平了777

回复
双指针也是a了78     
1
回复
发布于 昨天 13:27
湖南

白面神君不白面

回复
先切割字符串，再用的set，78   

这个set好像有点牛逼？













## 第三题据说回溯

我的笔试一共有四道算法。第一道是01背包，算是签到题吧，除了描述之外也没有改别的条件，有刷过dp的同学应该问题不大。这也是笔试传统了，第一道题通常难度不会太大，大家不用太过于担心。第二道是带权图的最短路径，在acm模式下图论的题目比较困难的就是构建了，但是只要耐心读懂题目，构建出邻接表，dfs/bfs即可破解。第三、第四道分别是任务处理和汉诺塔，这里不展开讲了。


可以留意到，多道算法题的解题思路大概率是不重复的，`dp、图论、回溯、二分、贪心、栈、堆、树`都有可能考察到，所以对于如何准备笔试，我总结以下这几点：

1、对于多类算法，先广度优先地学习，每种算法都简单过一遍，能用这些算法解决easy题，对每个算法有基础的概念之后，再深入学习某一类算法；

2、算法是日积月累的，培养一天刷1～2道题的习惯

3、算是我总结的偷机小技巧，在时间紧迫下，`链表和树可以设为优先级较低的类型`，因为结构的特殊，acm模式很少会出链表和树相关的题目，当然这并不绝对，仅对于时间紧急情况。


2、不用恐惧手撕，手撕通常来说是比笔试简单的，如果笔试能a出来题目，手撕更不是问题了，我面试过程的唯一一道手撕是LRU，有刷算法的同学应该知道这不是一道难题；



LRU-least recently used-最近最少使用算法，是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据。LRU常用语缓存系统的淘汰策略。


4.Redis LRU算法实现

分析Redis LRU实现之前，我们先了解一下Redis缓存淘汰策略。

当Redis内存超出物理内存限制时，内存会频繁的磁盘swap区交换数据，而交换会导致redis对外服务性能的急剧下降，这在生产环境是不允许的。说得更明白些，在生产环境是不允许交换行为的，通过设置maxmemory可限制内存超过期望大小。









## 回溯法
回溯法（Backtracking）是一种通过探索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化来撤销上一步或上几步的计算，即通过“回溯”来尝试其他的候选解。回溯法通常用于解决组合问题、排列问题、子集问题、图的着色问题、旅行商问题（TSP）等。

例子：解决八皇后问题
八皇后问题是一个经典的问题，要求在一个8x8的`棋盘上放置八个皇后，使得她们互不攻击，即任意两个皇后都不在同一行、同一列或同一对角线上`。

    解题思路
    初始化：创建一个8x8的棋盘，并初始化一个数组来记录每一列上皇后的位置（即行号）。
    放置皇后：从第一行开始，尝试在每一列放置皇后。
    检查冲突：对于每一个放置的皇后，检查其是否与已放置的皇后冲突（同行、同列、同对角线）。
    回溯：如果当前位置无法放置皇后（即存在冲突），则回溯到上一行，尝试在该行的下一列放置皇后。如果当前行所有列都尝试完毕且无法放置，则继续回溯到上一行。
    成功放置：如果成功地在第8行放置了皇后，则找到了一个解。
    寻找所有解：找到一个解后，回溯到上一行，继续寻找其他可能的解。

    初始化棋盘和列位置数组  
    for 第1行到第8行:  
        for 第1列到第8列:  
            如果 当前位置可以放置皇后:  
                放置皇后  
                if 当前行 == 8:  
                    找到一个解，打印棋盘  
                    回溯（移除当前行的皇后）  
                else:  
                    递归到下一行  
            回溯（尝试当前行的下一列）

通过回溯法，我们可以系统地探索所有可能的放置方式，直到找到所有符合条件的解。这种方法虽然可能需要探索大量的候选解，但它能保证找到`所有解`（如果存在的话）。


    def is_safe(board, row, col):  
        # 检查列  
        for i in range(row):  # 只检查已有的，走过的。
            if board[i] == col:  # 这是什么？ board索引是行 值是列 假设0行1列已有值，当到达1行时检查board 发现 for col in range(n): 的col其实不可用
                return False  
        
        # 检查左上对角线  
        for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)):  # 这些设置得比较巧妙 
            if board[i] == j:  
                return False  
        
        # 检查右上对角线  
        for i, j in zip(range(row-1, -1, -1), range(col+1, len(board))):  
            if board[i] == j:  
                return False  
        
        return True  
    
    def solve_n_queens(n):  # 这个函数大概能看懂
        def backtrack(row, board):  
            if row == n:  
                result = [''.join('Q' if j == col else '.' for j in range(n)) for col in board]  
                print('\n'.join(result))  
                return  
            
            for col in range(n):  
                if is_safe(board, row, col):  
                    board[row] = col  
                    backtrack(row + 1, board)  
                    board[row] = -1  # 回溯，重置当前行皇后的位置  
    
        board = [-1] * n  # [-1, -1, -1, -1, -1, -1, -1, -1]
        backtrack(0, board)  
    
    # 调用函数解决8皇后问题  
    solve_n_queens(8)

在这个代码中，is_safe 函数用于检查在棋盘的 (row, col) 位置放置皇后是否安全。它检查同一列、左上对角线和右上对角线上是否有其他皇后。

solve_n_queens 函数是主函数，它接受一个参数 n，表示棋盘的大小（n x n）。它定义了一个内部函数 backtrack，该函数递归地尝试在每一行放置皇后，并使用 board 列表来跟踪每一行皇后的列位置。如果成功地在第 n 行放置了皇后，则找到了一个解决方案，并将其打印出来。然后，它回溯到上一行，尝试其他可能的列位置。

最后，solve_n_queens(8) 调用用于解决8皇后问题，并打印出所有可能的解决方案。

下面是一个使用Python实现的八皇后问题的具体代码示例。这个示例使用了回溯法来找到所有可能的解决方案，并将每个解决方案打印到控制台上。


    Q.......
    ....Q...
    .......Q
    .....Q..
    ..Q.....
    ......Q.
    .Q......
    ...Q....
    Q.......
    .....Q..
    .......Q
    ..Q.....
    ......Q.
    ...Q....

# 华为
华为的笔试模拟题的比例非常大，对于理解能力要求比较高，所以读题一定要十分仔细。这两年华为的offer含金量上升大家也都知道，hc数量也不会太少，还是要认真对待的。

本次笔试难度适中，但依旧是华为比较明显的风格，代码不是太好写。

第1题是比较基础的模拟题，理解好题目，进行模拟操作即可。但是需要注意里面的一些特殊要求，否则很容易没分。

第2题也是偏向于模拟的题，但其中有一个思维的小点需要反应得过来，否则也很容易拿不到大的分数。

第3题则是一个暴力解的题目，枚举的思路比较繁琐，但是难度也不大的，注意好有效的剪枝即可。(这一题可以参考米哈游20240813的第二题)

## 第1题 nums = [int(c) for c in input().split()] 。使用set TypeError: unhashable type: 'list'。list不能直接当成set或字典的键，只能当值

数据重删
数据重删是一种节约存储空间的技术，通常情况下，在数据存储池内是有很多重复的数据块，重删则是将这些重复的数据块找出并处理的技术。简单地说重删，就是将N份重复的数据块仅保留1份，并将N-1份数据的地址指针指向唯一的那一份。 我们输入一串存储的数据，用N表示数据个数，用K表示数据块的大小，设计一个方法判断当前数据块是否和前面的数据块有重复，两个数据块内容完全一样则表示重复，如果重复则将这个数据块删除，并且在第一个出现数据块的后面增加重复数据的计数，输出经过重删之后的数据内容。

输入
8 输入数据的个数 2 数据块的大小 1 2 3 4 1 2 3 4 依次是数据值

注意： 输入的数据值都是正整数 1 <= K <= 10^6 1<= N <= 10^2

输出
1 2 2 3 4 2 输出结果为去除重复数据后的结果，输出结果最后没有空格，以数字结尾，输出内容不改变输入数据块的顺序

样例1
输入：

    8 
    2 
    1 2 3 4 1 2 3 4
输出：

    1 2 2 3 4 2
解释：

总共8个数据，数据块的大小为2，按照窗口2进行切片表示一个数据块，分别得到数据块为 [1, 2]，[3, 4]，[1, 2]，[3, 4]。其中第一个数据块和第三个数据块相同，第二个数据块和第四个数据块相同，可以分别进行重删。重删之后数据块[1,2]的计数变为2，表示有两个相同的数据块[1,2]；同理[3,4]的数据块计数也变为2

样例2
输入：

    8 
    3 
    3 4 5 3 4 5 5 4
输出：

    3 4 5 2 5 4 1
解释：

总共8个数据，数据块的大小为3，按照窗口3进行切片表示一个数据块，分别得到数据块为 [3, 4, 5]，[3, 4, 5]，[5, 4]，其中 [3, 4, 5] 和 [3, 4, 5] 是重复的窗口，可以进行重删。重删之后数据块[3,4,5]的计数变为2，由于剩余数据块不满足3个连续数据，所以下一个数据块只包含 [5, 4]，[5,4]和前面的数据块不同，所以保留下来，只有一份。


先直接input读split map转int list       
然后根据 第二个数 划分第三组数      
构成新list 取set?     
可以直接for循环计数        

    print(set([[1,2],[1,2],[2]]))
          ^^^^^^^^^^^^^^^^^^^^^^
TypeError: unhashable type: 'list'

思路与代码

哈希表模拟。

题目还是比较简单的，用python处理起来会方便太多了。大体的思想就是按照题目要求去截取字符串，然后用哈希表来统计出现次数。需要注意的是，需要统计每个数据块第一次出现的下标，最后的输出结果需要按照这个下标来排序。（最后不要有空格或者换行符）

需要统计每个数据块第一次出现的下标       
也不是不行

    N = int(input())
    blk = int(input())
    nums = [int(c) for c in input().split()]

    res = {}

    for i in range(0, N, blk):挺讲究
        cur_blk = nums[i:i + blk]
        tp = tuple(cur_blk) # 
        if tp not in res:
            res[tp] = [i, 1]  # 下标、出现次数
        else:
            res[tp][1] += 1

        挺好的

    sorted_res = sorted(res.items(), key=lambda x: x[1][0]) 含义未知
    ans = []
    for key, value in sorted_res:
        ans.extend(key)  # 将整个数据块加入结果
        ans.append(value[1])  # 加入计数

    print(' '.join(map(str, ans)))

讲究

    res = {}
    tp = tuple([1]) #   
    res[tp] = [1, 1] 
    print(res)

{(1,): [1, 1]}


    res = {}
    tp = [12] 
    res[tp] = [1, 1] 
    print(res)
    print(a)


    res[tp] = [1, 1]
    ~~~^^^^
TypeError: unhashable type: 'list'

果然list不能直接当成set或字典的键，只能当值


1 2 2 3 4 2 输出结果为去除重复数据后的结果，输出结果最后没有空格，以数字结尾，输出内容不改变输入数据块的顺序

需要统计每个数据块第一次出现的下标，最后的输出结果需要按照这个下标来排序。（最后不要有空格或者换行符）

![alt text](assets_picture/牛客题/image-12.png)

![alt text](assets_picture/牛客题/image-13.png)

字典进入sorted竟然变成元组

出来后是list和套的新元组

![alt text](assets_picture/牛客题/image-14.png)

元组竟然也能像list一样被extend


## 第2题


DevOps任务调度
某Devops系统有一批并发任务需要匹配合适的执行机调度执行，任务和执行机都具有CPU型（用0表示）和IO型（用1表示）的区别，此外还有一种通用型执行机（用2表示），一批任务和执行机的类型分别用数组tasks、machines表示，tasks[i]表示第i个任务，machines[i]表示执行机的类型。每台CPU型、IO型执行机只能执行一个对应类型的任务，而通用型执行机既能执行CPU类型任务也能执行IO类型任务。

假设现有的匹配策略如下: 任务需要按照优先级从高到低依次匹配执行机（i=0优先级最高）,因此每一轮选择任务数组头部(i=0)的任务去匹配空置执行机数组头部（i=0）的执行机，若任务与执行机类型匹配，则代表该任务调度成功，把该执行机从空置执行机数组中移除。若任务与执行机的类型不匹配，则将执行机放到执行机数组尾部，循环该过程直到任务全部匹配成功或当前任务无法被所有剩余空置执行机匹配。

现规定任意时刻都可以选择使用通用执行机，但一旦选择将某个类型的任务匹配通用型执行机，则所有通用型机器都只能用于执行该类型的任务，为了避免任务排队阻塞，请返回现有匹配策略下剩下的最小空置执行机数量。


输入
输入共3行
首行是一个正整数n，表示任务数量以及执行机数量
第2行包含n个整数，以空格分隔，表示为任务数组tasks
第3行包含n个整数，以空格分隔，表示为空置执行机数组machines
数据范围：1<=n<=100, 0<=tasks[i]<=1，0<=machines[i]<=2。
输出
一行一个整数，代表当前匹配策略下剩下的最小空置执行机数量。

样例1
输入：

    3 
    1 0 1 
    1 2 0
输出：

    0
解释：

第一轮 任务数组头部类型1，空置执行机数组头部类型1，匹配成功，任务数组变为[0, 1],空置执行机数组变为[2, 0] 第二轮 任务数组头部类型0，空置执行机数组头部类型2，若不选择类型2的执行机执行类型0的任务，将执行机放回数组尾部，任务数组不变为[0, 1],空置执行机数组变为[0, 2] 第三轮 任务数组头部类型0，空置执行机数组头部类型0，匹配成功，任务数组变为[1],空置执行机数组变为[2] 第四轮 任务数组头部类型1，空置执行机数组头部类型2，任务类型1选择匹配执行机类型2，因此剩下的最小空置执行机数量为0

样例2
输入：

    4 
    1 0 1 1 
    1 0 2 0 
输出：

    1
解释：

第一轮 任务数组头部类型1，空置执行机数组头部类型1，调度成功，任务数组变为[0,1,1],空置执行机数组变为[0,2,0] 第二轮 任务数组头部类型0，空置执行机数组头部类型0，调度成功，任务数组变为[1,1],空置执行机数组变为[2,0] 第三轮 任务数组头部类型1，空置执行机数组头部类型2，类型1的任务选择匹配类型2的执行机，任务数组变为[1],空置执行机数组变为[0] 第四轮 任务数组头部类型1，空置执行机数组头部类型0，无法匹配，剩下的最小空置执行机数量为1

任务和执行机都具有CPU型（用0表示）和IO型（用1表示）的区别，此外还有一种通用型执行机（用2表示），一批任务和执行机的类型分别用数组tasks、machines表示，tasks[i]表示第i个任务，machines[i]表示执行机的类型。每台CPU型、IO型执行机只能执行一个对应类型的任务，而通用型执行机既能执行CPU类型任务也能执行IO类型任务。

看起来直接遍历列表写匹配就行了 不行就切片去掉然后append


假设现有的匹配策略如下: 任务需要按照优先级从高到低依次匹配执行机（i=0优先级最高）,因此每一轮选择任务数组头部(i=0)的任务去匹配空置执行机数组头部（i=0）的执行机，若任务与执行机类型匹配，则代表该任务调度成功，把该执行机从空置执行机数组中移除。若任务与执行机的类型不匹配，则将执行机放到执行机数组尾部，循环该过程直到任务全部匹配成功或当前任务无法被所有剩余空置执行机匹配。

现规定任意时刻都可以选择使用通用执行机，但一旦选择将某个类型的任务匹配通用型执行机，则所有通用型机器都只能用于执行该类型的任务，为了避免任务排队阻塞，请返回现有匹配策略下剩下的最小空置执行机数量。


好像还是有难度的 因为2的存在 而且2会变身

然后优先级其实也不太明白


思路与代码

枚举+队列模拟。

核心是这句话：对于通用性的机器2，无非就两种选择：改成0或者改成1，我们尝试两种方案，取最小值即可。


这句话看不明白         
模拟的过程可以用一个双端队列来进行，只要当前任务与当前执行机不匹配，那么就把执行机换到队尾，这个过程最多执行的次数不得超过当前执行机的队列长度。最后返回执行机队列的剩余长度即可，因为无法匹配的机器就等价于无法匹配的任务。


    from collections import deque

    n = int(input())
    tasks = [int(c) for c in input().split()]
    machines = [int(c) for c in input().split()]

    # 两种选择，要么转0，要么转1

    def solve(machines):
        machines = deque(machines)
        for i, task in enumerate(tasks):
            cnt = 0
            while cnt <= len(machines) and task != machines[0]:
                left = machines.popleft()
                machines.append(left)
                cnt += 1

            if cnt >= len(machines):
                break
            if task == machines[0]:
                machines.popleft()
        return len(machines)


    print(min(solve([0 if x == 2 else x for x in machines]) , solve([1 if x == 2 else x for x in machines])))

    # 两种选择，要么转0，要么转1

他直接把两种选择结果全部算出来 取min

把以下问题解决
好像还是有难度的 因为2的存在 而且2会变身

然后又全部算移动次数 只要移动次数不超过剩余长度就直至移动

题目也没说数据量级

默认枚举

    while cnt <= len(machines) and task != machines[0]:
        left = machines.popleft()
        machines.append(left)
        cnt += 1

他甚至不考虑剩余长度 直接整个长度

        machines.popleft()
    return len(machines)

核心就是遍历 task       
pop machine 返回machine长度

还行吧 就是挺溜的


### deque 很方便 反转列表-其实也可以切片反转 或者 appendleft popleft extendleft。基本就是在列表外，套一层创建起来，然后加了几个left功能

![alt text](assets_picture/牛客题/image-15.png)

![alt text](assets_picture/牛客题/image-16.png)

列表竟然还能指定pop index



d = deque([1, 2, 3])


append(x): 在队列的右端添加一个元素 x。

python
复制代码
d.append(4)  # d -> deque([1, 2, 3, 4])
appendleft(x): 在队列的左端添加一个元素 x。

python
复制代码
d.appendleft(0)  # d -> deque([0, 1, 2, 3, 4])
pop(): 移除并返回队列右端的元素。

python
复制代码
d.pop()  # 返回 4, d -> deque([0, 1, 2, 3])
popleft(): 移除并返回队列左端的元素。

python
复制代码
d.popleft()  # 返回 0, d -> deque([1, 2, 3])
extend(iterable): 将 iterable 中的元素添加到队列的右端。

python
复制代码
d.extend([4, 5])  # d -> deque([1, 2, 3, 4, 5])
extendleft(iterable): 将 iterable 中的元素逆序添加到队列的左端。

python
复制代码
d.extendleft([0, -1])  # d -> deque([-1, 0, 1, 2, 3, 4, 5])
rotate(n): 向右旋转队列 n 步（如果 n 为负，则向左旋转）。

python
复制代码
d.rotate(1)  # d -> deque([5, -1, 0, 1, 2, 3, 4])
d.rotate(-1) # d -> deque([-1, 0, 1, 2, 3, 4, 5])
clear(): 清空队列。

python
复制代码
d.clear()  # d -> deque([])
count(x): 返回队列中元素 x 的个数。

python
复制代码
d = deque([1, 2, 3, 1, 1])
d.count(1)  # 返回 3
reverse(): 将队列反转（in-place 操作）。

python
复制代码
d.reverse()  # d -> deque([5, 4, 3, 2, 1, 0, -1])
maxlen: deque 可以设定最大长度，超出长度时会从另一端删除元素。

python
复制代码
d = deque([1, 2, 3], maxlen=3)
d.append(4)  # d -> deque([2, 3, 4])
这些方法使得 deque 在处理需要频繁从两端操作元素的场景中非常有用，如实现队列、双端队列等数据结构。

### 字符串在python里能直接reverse吗
ChatGPT 说：
ChatGPT
在 Python 中，字符串是不可变的对象，因此不能直接修改它们。不过，你可以通过多种方式创建一个字符串的反转版本。以下是几种常见的方法：

1. 使用切片（Slicing）
这是最常用和简单的方法。

python
复制代码
s = "hello"
reversed_s = s[::-1]
print(reversed_s)  # 输出: "olleh"
2. 使用 reversed() 函数和 join()
reversed() 函数返回一个反转的迭代器，可以结合 join() 将其转换为字符串。

python
复制代码
s = "hello"
reversed_s = ''.join(reversed(s))
print(reversed_s)  # 输出: "olleh"
3. 使用循环
你可以通过循环手动构建反转的字符串。

python
复制代码
s = "hello"
reversed_s = ""
for char in s:
    reversed_s = char + reversed_s
print(reversed_s)  # 输出: "olleh"
4. 使用 reduce() 函数
reduce() 函数可以将字符串逐步累积反转。

python
复制代码
from functools import reduce

s = "hello"
reversed_s = reduce(lambda x, y: y + x, s)
print(reversed_s)  # 输出: "olleh"


## 第三题 勉强能理解 dfs回溯 记录最小time 多次放入 返回恢复


# 快手 823

第一题是基础的栈模拟，难度比较低。

第二题也是基础的动态规划，难度比较低。

第三题难度比较大，需要先预处理，然后使用状压来实现dp，这个考点并不常见。

## 题目一
题目描述给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s（1 <= s.length <= 1e4) ，判断字符串是否有效。如果有效，输出有效括号的个数。如果无效，则输出False。

有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。每个右括号都有一个对应的相同类型的左括号。


输入

    5
    ()
    ([])
    ([[}]]){
    ){}()
    ))(())
输出

    1
    2
    False
    False
    False

### 队列
太简单 列表轻松实现 甚至用不到那个双端列表

    from collections import deque
    d = deque([1, 2, 3])

封装也很简单

rotate(n): 向右旋转队列 n 步（如果 n 为负，则向左旋转）。

rotate

reverse

extendleft

popleft

appendleft

    [1,2,3].reverse   <built-in method reverse of list object at 0x000001FA470AD100> 这好像是获得了一个方法？
    [1,2,3].reverse()   None



    a=[1,2,3]
    a.reverse   [1, 2, 3]
    a=[1,2,3]
    a.reverse()   [3, 2, 1]


    a=[1,2,3]
    a.reverse   [1, 2, 3]
    a=[1,2,3]
    a.reverse()   [3, 2, 1]
    a=3e-5  3e-05
    a*10  0.00030000000000000003
    a*100  0.003



## 题目二

题目描述

Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。

    1 2 3 4 5
    16 17 18 19 6
    15 24 25 20 7
    14 23 22 21 8
    13 12 11 10 9
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。答案就是25.

输入的第一行表示区域的行数R和列数C(1 <= R,C <= 100)。下面是R行，每行有C个整数，代表高度h，0<=h<=10000。

输出最长区域的长度。

输入

    5 5
    1 2 3 4 5
    16 17 18 19 6
    15 24 25 20 7
    14 23 22 21 8
    13 12 11 10 9
输出25


感觉是回溯 同时记录最长道？但最高不一定最长把         
dp?       

好难写

最简单的就是对着用例直接解决

啥都不考虑 直接找最顶点 然后贪心直接找 不管什么窗口大小 然后记录 直接输出答案

第二题也是基础的动态规划，难度比较低。

我靠 难度低？

记忆化搜索，用dp{i,j}表示从(i,j)出发能滑的最远距离，用dfs搜索，若dp{i,j}>0即已经计算过，直接返回值即可，否则按照dfs思路递推计算其最大值，递推式为：dp{i,j}=max(dp{i,j},dfs(x,y)+1)（（i,j)与(x,y)相邻，且a{ x, y}<a{i, j}）


还可以但是想不到

他这个就是搜索所有答案 不见得复杂度低 但是他能形成代码啊 我的逻辑感觉没有那么严谨 简洁


    #include<cstdio>
    #include<algorithm>
    using namespace std;

    int r,c,res;
    int a[105][105],dp[105][105];
    int go[4][2]={-1,0,0,1,1,0,0,-1}; 这个挺好

    int dfs(int x,int y){
        if(dp[x][y]>0) return dp[x][y];
        dp[x][y]=1;
        for(int i=0;i<4;++i){
            int xx=x+go[i][0],yy=y+go[i][1];
            if(xx>=0&&xx<r&&yy>=0&&yy<c&&a[xx][yy]<a[x][y])
                dp[x][y]=max(dp[x][y],dfs(xx,yy)+1); 这个挺核心的。这个好像是从叶子节点找到最大才返回 这是不是有点说法？ 反正不管 dp就是一股脑找最大 不管是二维还是一维dp
        }
        return dp[x][y]; 遍历完四个方向 贪心取出 所以也只是简单的贪心 同时遍历完所有的可能
    }

    int main(){
        scanf("%d%d",&r,&c);
        for(int i=0;i<r;++i)
            for(int j=0;j<c;++j)
                scanf("%d",&a[i][j]);
        for(int i=0;i<r;++i)
            for(int j=0;j<c;++j){
                int tmp=dfs(i,j); 直接对每个点找 为了通过率真实拼了 复杂度嗖嗖涨
    但是本质还是最近贪心
                if(tmp>res) res=tmp;
            }
        printf("%d\n",res);
        return 0;
    }


## 第三题 太难看不懂说不清


# shopee 0825
过虾皮可能学历卡的比较紧一点，hc不多的，招聘周期也不长。没投的得赶紧投了。

本次笔试难度比较低，有一定刷题基础的同学应该都可以解决。第一题是LC经典的链表处理题了，注意好链表的指针操作即可。第二题则是基础的数组搜索问题，排序后双指针即可。第三题是基础的DP，套用模板即可。



## 第一题
给定单链表头节点head,实现一个调整单链表的函数，使得海k个节点之间逆序，如果最后不 够K个节点，则不进行调整。

输入

1,2,3,4,5,6,7,8,9,10,11,12,13,3

输出

3,2,1,6,5,4,9,8,7,12,11,10,13


力扣25题原题，可参考官方题解,虾皮均为力扣模式，不需要手写输入输出


    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* dummy = new ListNode(0, head);
        ListNode* cur = dummy;
        while (true) {
            auto cur1 = cur;
            for (int i = 0; i < k && cur1; i++) {
                cur1 = cur1->next;
            }
            if (!cur1)
                break;
            auto a = cur->next, b = a->next;
            for (int i = 0; i < k - 1; i++) {
                auto c = b->next;
                b->next = a;
                a = b, b = c;
            }
            auto t = cur->next;
            cur->next->next = b;
            cur->next = a;
            cur = t;
        }
        return dummy->next;
    }


写得太乱 完全无法明白含义


## 第二题
在两个数组中找出满足要求的两个数 详细描述 给定正整数X,两个正整数数组Arr1和Arr2,请在Arr1和Arr2中各找一个数，使得这两个数字之 和与X最接近，输出两个值对应的下标。



输入[1,5,13,15],[10,11,17,20],20输出[0,3]


这也不简单啊

第二题则是基础的数组搜索问题，排序后双指针即可

一步一步 依次移动？


思路与代码


对数组 Arr1 和 Arr2 分别进行排序，并保留它们的原始下标。使用双指针，一个指向 Arr1 的起始位置，另一个指向 Arr2 的末尾。计算当前两个指针所指向元素的和与目标值 X 的差距，并根据差距调整指针的移动方向。记录最小差距及其对应的下标。当两个指针相遇时，输出对应的下标。


下标如何保留

？？

    vector<int> findClosetPair(vector<int>& arr1, vector<int>& arr2, int x) {
        int n1 = arr1.size();
        int n2 = arr2.size();
        
        // 存储原始下标的数组
        vector<pair<int, int>> arr1Indexed, arr2Indexed;
        
        for (int i = 0; i < n1; ++i) {
            arr1Indexed.push_back({arr1[i], i});  竟然用字典存下标？重复呢？
        }
        for (int i = 0; i < n2; ++i) {
            arr2Indexed.push_back({arr2[i], i});
        }
        
        // 对两个数组按值排序
        sort(arr1Indexed.begin(), arr1Indexed.end());
        sort(arr2Indexed.begin(), arr2Indexed.end());
        
        int left = 0;
        int right = n2 - 1; 好像有些巧妙啊 能避免错过？
        int closestSum = INT_MAX;
        int closestLeft = 0, closestRight = 0;
        
        // 使用双指针法
        while (left < n1 && right >= 0) {
            int sum = arr1Indexed[left].first + arr2Indexed[right].first;
            int diff = abs(sum - x);
            
            // 如果找到更接近的值，更新最近的下标
            if (diff < closestSum) {
                closestSum = diff;
                closestLeft = arr1Indexed[left].second;
                closestRight = arr2Indexed[right].second;
            }
            
            // 根据sum和x的比较结果来移动指针
            if (sum < x) {
                left++; 
            } else {
                right--;
            }
        }
        
        return {closestLeft, closestRight};
    }


好像不是字典 而是元组 重复没关系


    from typing import List, Tuple

    def find_closest_pair(arr1: List[int], arr2: List[int], x: int) -> Tuple[int, int]:
        n1 = len(arr1)
        n2 = len(arr2)
        
        # 存储原始下标的数组
        arr1_indexed = [(value, idx) for idx, value in enumerate(arr1)] 巧妙
        arr2_indexed = [(value, idx) for idx, value in enumerate(arr2)]
        
        # 对两个数组按值排序
        arr1_indexed.sort()
        arr2_indexed.sort()
        
        left = 0
        right = n2 - 1
        closest_sum = float('inf')
        closest_left = 0
        closest_right = 0
        
        # 使用双指针法 比较巧妙
        while left < n1 and right >= 0:
            sum_value = arr1_indexed[left][0] + arr2_indexed[right][0]
            diff = abs(sum_value - x)
            
            # 如果找到更接近的值，更新最近的下标
            if diff < closest_sum:
                closest_sum = diff
                closest_left = arr1_indexed[left][1]
                closest_right = arr2_indexed[right][1]
            
            # 根据sum和x的比较结果来移动指针
            if sum_value < x:
                left += 1
            else:
                right -= 1
        
        return (closest_left, closest_right)



arr1_indexed.sort() 是依据 value 进行排序的。

在 Python 中，sort() 函数默认根据元组的第一个元素（即 value）进行排序。如果 value 相同，它会进一步根据第二个元素（即 idx）排序，但在这个代码中，主要是依据 value 进行排序。

元组记录信息 然后又用了 两边的双指针










## 第三题

假设货车的容量为V(正整数，0<=V<=20000),货物的总个数为(0<n<=32)。请你写一个程序，找出如何将货车的容量充分利用（剩余空间最小）。输入：V货车的容量，数组n表示每个货物占的体积输出：一个整数，表示货车的剩余容量

输入24,8,3,12,7,9,7

输出0

没写清楚


思路与代码


这个问题可以看作是“背包问题”的变种，我们需要找到一种货物的组合，使得其总容量尽量接近货车的容量V，这样剩余空间最小。使用一个二维数组dp[i][j]表示前i个货物中选择体积不超过j的最大体积，这样最后可以通过V - dp[n][V]来得到最小的剩余空间。

第三题是基础的DP，套用模板即可。


    int bestFit(int v, vector<int>& item) {
        int n = item.size();
        vector<int> dp(v + 1, 0);

        // 动态规划，计算在容量为v的情况下，能够装载的最大体积
        for (int i = 0; i < n; ++i) {
            for (int j = v; j >= item[i]; --j) {
                dp[j] = max(dp[j], dp[j - item[i]] + item[i]);
            }
        }

        // 返回剩余空间
        return v - dp[v];
    }


    from typing import List

    def best_fit(v: int, item: List[int]) -> int:
        n = len(item)
        dp = [0] * (v + 1)

        # 动态规划，计算在容量为v的情况下，能够装载的最大体积
        for i in range(n):
            for j in range(v, item[i] - 1, -1):
                dp[j] = max(dp[j], dp[j - item[i]] + item[i])

        # 返回剩余空间
        return v - dp[v]

dp 数组用于存储在不同容量下可以装载的最大体积。
外层循环遍历每个物品，内层循环从当前容量 v 倒序更新 dp 数组，确保每个物品只被计算一次。
最终返回的是总容量 v 减去可以装载的最大体积，即剩余的空间。


没看懂 题目和题解都太乱



# 得物 0828
## 第一题

    import sys

    n,k = map(int,input().split(' '))
    a= list(map(int,input().split(' ')))

    win_rate=0

    per_win_rate = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            per_win_rate[i][j] = a[i]/(a[i]+a[j])
    win_1_rate=[]

    for i in range(n):
        #if k==1
        temp=1
        for j in range(n):
            if i==j: continue
            temp *= per_win_rate[i][j]
        #if k=2:
        # win_rate += temp
        win_1_rate.append(temp)

    for i in range(n):
        if k==1:
            win_rate+=win_1_rate[i]
        if k==2:
            for j in range(n):
                if j==i: continue
                win_rate+=win_1_rate[i]*win_1_rate[j]
        if k==3:
            for j in range(n):
                if j==i: continue
                for k in range(n):
                    if k==i or k==j: continue
                    win_rate+=win_1_rate[i]*win_1_rate[j]*win_1_rate[k]


    print(f'{win_rate:.2f}')

只会这么写 太蠢了





您可以将此代码简化为一个更通用的版本，以支持任意的 k 值。考虑到 k 可能是一个较大的未知数（例如 100 或 200），我们可以利用递归或 itertools 模块中的 combinations 函数来生成所有的组合并计算 win_rate。

以下是使用 itertools.combinations 的简化版本：

    python
    复制代码
    from itertools import combinations

    win_rate = 0

    # 生成所有长度为 k 的组合
    for combination in combinations(range(n), k):
        product = 1
        for index in combination:
            product *= win_1_rate[index]
        win_rate += product
解释：
combinations(range(n), k)：生成长度为 k 的所有可能索引组合。
遍历每个组合：对每个组合计算其乘积，并将结果累加到 win_rate。
这种方法简化了代码逻辑，避免了多个嵌套的 for 循环，使其更加通用和灵活。


记忆里好像是用三维数组做的 但是这里说去递归

使用递归方法来计算 win_rate，我们可以递归地选择当前的元素并计算所有可能的组合乘积。递归的基本思想是，在每一层选择一个元素，然后递归地处理剩余的元素，直到达到所需的组合长度 k。

下面是使用递归来实现的代码：

    python
    复制代码
    def calculate_win_rate(n, k, win_1_rate):
        def recursive_combination(current_index, current_product, remaining_k):
            # 如果已经选择了k个元素，则将当前乘积加入win_rate
            if remaining_k == 0:
                return current_product
            
            win_rate = 0
            # 从当前索引开始，选择下一个元素
            for i in range(current_index, n):
                win_rate += recursive_combination(i + 1, current_product * win_1_rate[i], remaining_k - 1)
            
            return win_rate

        # 初始调用，开始索引为0，乘积为1，剩余需要选择的k个元素
        return recursive_combination(0, 1, k)

    # 示例使用
    n = 5  # 假设n的值为5
    k = 3  # 假设k的值为3
    win_1_rate = [0.1, 0.2, 0.3, 0.4, 0.5]  # 假设win_1_rate的值
    win_rate = calculate_win_rate(n, k, win_1_rate)
    print(win_rate)
解释：
recursive_combination 函数:

current_index：当前考虑的索引。
current_product：当前已选择元素的乘积。
remaining_k：还需要选择的元素个数。
递归终止条件：当 remaining_k == 0 时，表示已经选择了 k 个元素，此时返回当前的乘积。

递归调用：在每一步，选择当前索引后的下一个元素，并递归地计算剩余的组合。

初始调用：从索引 0 开始，初始乘积为 1，需要选择 k 个元素。


已经感觉很优美了


dp有点看不懂

使用动态规划（DP）可以有效地优化这个问题，避免递归可能带来的性能瓶颈。我们可以构建一个 DP 数组来保存中间结果，以避免重复计算。

动态规划解法
我们定义一个二维数组 dp[i][j] 来表示从前 i 个元素中选取 j 个元素的组合的总乘积和。最终的答案 win_rate 将会是 dp[n][k]。

动态规划状态转移方程：
初始化:

dp[0][0] = 1：从 0 个元素中选 0 个的乘积和是 1（即没有选任何元素）。
dp[i][0] = 1：从前 i 个元素中选 0 个的乘积和也是 1（没有选任何元素的乘积）。
状态转移方程:

如果 j > 0，则 dp[i][j] = dp[i-1][j] + dp[i-1][j-1] * win_1_rate[i-1]。
解释：dp[i][j] 表示前 i 个元素中选 j 个的总和。
不选第 i 个元素: dp[i-1][j]
选第 i 个元素: dp[i-1][j-1] * win_1_rate[i-1]
实现代码：

    python
    复制代码
    def calculate_win_rate_dp(n, k, win_1_rate):
        # 初始化DP数组, 大小为 (n+1) x (k+1)
        dp = [[0] * (k + 1) for _ in range(n + 1)]

        # 初始化基准情况
        dp[0][0] = 1  # 从0个元素中选择0个的情况
        for i in range(1, n + 1):
            dp[i][0] = 1  # 从前i个元素中选择0个的情况

        # 填充DP表
        for i in range(1, n + 1):
            for j in range(1, k + 1):
                dp[i][j] = dp[i-1][j]  # 不选当前元素
                if j > 0:
                    dp[i][j] += dp[i-1][j-1] * win_1_rate[i-1]  # 选当前元素

        # 返回从n个元素中选取k个的总乘积和
        return dp[n][k]

    # 示例使用
    n = 5  # 假设n的值为5
    k = 3  # 假设k的值为3
    win_1_rate = [0.1, 0.2, 0.3, 0.4, 0.5]  # 假设win_1_rate的值
    win_rate = calculate_win_rate_dp(n, k, win_1_rate)
    print(win_rate)
优化和解释：
时间复杂度: 该算法的时间复杂度为 O(n * k)，因为我们填充了一个大小为 n * k 的 DP 表格。
空间复杂度: 空间复杂度也是 O(n * k)，但可以进一步优化到 O(k)，因为我们只需要前一行的结果来计算当前行。
空间优化的 DP 解法：
如果我们只使用一个一维数组 dp[j] 来存储当前行的数据（从大到小更新），则可以将空间复杂度优化到 O(k)：

    python
    复制代码
    def calculate_win_rate_optimized_dp(n, k, win_1_rate):
        # 初始化一维DP数组
        dp = [0] * (k + 1)
        dp[0] = 1  # 基准情况

        # 填充DP数组
        for i in range(1, n + 1):
            # 从后向前遍历以避免覆盖掉当前需要的状态
            for j in range(k, 0, -1):
                dp[j] += dp[j - 1] * win_1_rate[i - 1]

        # 返回从n个元素中选取k个的总乘积和
        return dp[k]

    # 示例使用
    n = 5  # 假设n的值为5
    k = 3  # 假设k的值为3
    win_1_rate = [0.1, 0.2, 0.3, 0.4, 0.5]  # 假设win_1_rate的值
    win_rate = calculate_win_rate_optimized_dp(n, k, win_1_rate)
    print(win_rate)
总结：
使用动态规划的方法可以有效避免递归带来的时间复杂度爆炸，同时可以进一步优化空间复杂度，适用于更大的 n 和 k。









# 图论？



# 结尾