# 笔试 暑期实习 牛客真题 oj在线编程 OJ在线编程常见输入输出练习 acm模式

## 练习1 循环行读取 for line in sys.stdin 一次读完所有
输出描述：
输出a+b的结果
示例1

    输入例子：
    1 5
    10 20
    输出例子：
    6
    30
解答

    import sys

    for line in sys.stdin: 循环行读取，应该是被读取成一个iterate了 列表还是其他什么结构位置 应该就是next输出 或者是yield
        a = line.split() 行读取 切分空格 列表返回
        print(int(a[0]) + int(a[1]))


## 练习2 按行读取 input()
输出描述：
输出a+b的结果
示例1

    输入例子：
    2
    1 5
    10 20
    输出例子：
    6
    30

答案

    import sys
    
    n = int(input())
    for _ in range(n):
        ls = list(map(int, input().split()))
        print(ls[0] + ls[1])



## 练习3 
输出描述：
输出一行排序后的字符串，空格隔开，无结尾空格
示例1

    输入例子：
    5
    c d a bb e
    输出例子：
    a bb c d e

## 练习4 map直接用于整个list 而且返回值需要再转回list。int直接用不需要括号int()
    for line in sys.stdin:
        a = line.split()
        b = list(map(int, a))
        print(sum(b))

加括号会导致       
Exception has occurred: TypeError
'int' object is not callable
  File "C:\Users\13162\Desktop\工作\多模\leetcode\test.py", line 25, in <module>
    b = list(map(int(), a))
        ^^^^^^^^^^^^^^^^^^^
TypeError: 'int' object is not callable


b = list(map(int, "1"))       
也可以单个直接用 当成列表处理 好像之前有个函数也是这种逻辑         
[1]

# oppo真题
## 第一题 n, m, k = map(int, input().split())
题意：给你 x, y, k 三个正整数，每次可以选择以下操作之一

    x = x - 1
    x = x / k 当且仅当 x % k == 0
问你将 x 变为 y 的最小操作次数。

输入：

三个正整数，

输出

一行一个正整数，表示最小操作次数

样例

输入：

10 4 2

输出

2

思路与代码   
贪心，若  x % k != 0 ，将 x 减少到能整除为止，只到不能整除且大于等于 y ，然后操作1即可。

n, m, k = map(int, input().split())

竟然可以这样


    def solve() -> None:
        n, m, k = map(int, input().split())
        if k == 1:
            print(m - n)
            return
        ans = 0
        
        while n != m:
            if n // k >= m:
                ans += n % k 这个地方太巧妙 不能说简单吧 
                n //= k 题目只给/ - % 竟然能联想到用 // 来减少运算
            else:
                n -= 1 
            ans += 1
        print(ans)    

    if __name__ == '__main__':
        solve()


按照 10 1 3的例子 我肯定会进入else 但是这个方法进竟然没进入


写得比较巧妙 加大理解难度



## 第二题 counter。 for k, v in cnta.items(), from collections import Counter
题意
小O有一个字符串 s，她希望重新排列这个字符串，并改变字符的大小写，使得新的字符串包含尽可能多的字符串 a 或者字符串 b 。请问小O最多能包含多少个子串 a 和 b ， 如果字符串t可以通过从字符串s的开头删除若干(可能为零或全部)字符以及字符串 s 的结尾删除若干(可能为零或全部)字符得到，则字符串 t 是字符串 s 的子串。

输入：

三行三个字符串，s, a, b 其中 a和b开头均为大写，其余均为小写

输出：

包含的子串个数

样例

输入：

    abcdefg
    Abc
    Fge
输出：

2


文字太多

由于 a 和 b 的首字母大写，所有不存在重叠，那么考虑贪心，枚举有多少个 a ,然后计算剩下的字符能组成多少个 b，取最大值即可

题解看不懂

    def solve() -> None:
        s = input()
        a = input()
        b = input()
        s = [x.lower() for x in s]
        a = [x.lower() for x in a]
        b = [x.lower() for x in b]
        cnts = Counter(s)
        cnta = Counter(a)
        cntb = Counter(b)
        ans = 0
        for i in range(len(s)+1):
            ok = True
            for k, v in cnta.items():
                if cnts[k] < i * v:
                    ok = False
            if ok:
                now = len(s)
                for k, v in cntb.items():
                    now = min(now, (cnts[k] - i * cnta[k]) // v)
                ans = max(ans, i + now)
        print(ans)

    if __name__ == '__main__':
        solve()

还是比较难的



这他妈还比较简单？ 两个for循环 一个min中带有// 还有一个max

true false循环设置 以及ok定义完全不知道在干什么

这三行代码使用 Counter 计算每个字符在字符串 s、a 和 b 中出现的频率。cnts、cnta 和 cntb 是三个字典，分别记录了字符及其出现次数。

ok 被用来检查在 s 中是否有足够的字符来满足 i 个字符串 a。

不要求顺序吗


for k, v in cnta.items(): 检查 cnts 中每个字符是否有足够的数量来满足 i 个 a 字符串的需求。   
如果满足条件，计算剩余字符能组成多少个 b 字符串，并更新最大值 ans。    
ans = max(ans, i + now): 通过比较当前计算的值和之前的最大值来更新 ans。   

这段代码的目的是从三个字符串 s、a 和 b 中计算一个最大值 ans。这个值表示你可以从字符串 s 中提取出尽可能多的字符串 a，然后用剩下的字符构造尽可能多的字符串 b。最终，ans 是这些字符串 a 和 b 组合的最大值。


确实牛逼

小O有一个字符串 s，她希望重新排列这个字符串，并改变字符的大小写，使得新的字符串包含尽可能多的字符串 a 或者字符串 b 。请问小O最多能包含多少个子串 a 和 b ， 如果字符串t可以通过从字符串s的开头删除若干(可能为零或全部)字符以及字符串 s 的结尾删除若干(可能为零或全部)字符得到，则字符串 t 是字符串 s 的子串。

题意好像比较矛盾


    now = len(s)
    for k, v in cntb.items():
        now = min(now, (cnts[k] - i * cnta[k]) // v)

如果满足条件，计算剩余字符能组成多少个 b 字符串，并更新最大值 ans。

整个下来挺绕 边界问题竟然被倒逼处理这么好

// v 不太懂是为什么

now = min(now, (cnts[k] - i * cnta[k]) // v)

这句代码 now = min(now, (cnts[k] - i * cnta[k]) // v) 的作用是计算在当前情况下，字符 k 能够满足的最大数量，并更新 now 为其最小值。它是用于确定在 i 个 a 组成的字符串后，剩下的字符能组成的 b 字符串的数量。


// v 是为了计算在剩余字符中，能够组成多少个 b 中需要的字符 k。即通过整数除法确定剩余的字符数量除以每个 b 字符串所需的字符数 v，从而得到可以组成的 b 字符串的数量。

假设我剩下 5个，v=5，那么//v得到1个？

ChatGPT 说：
ChatGPT
是的，正如你所理解的，如果剩下 5 个字符，而每个 b 字符串需要 5 个这样的字符，那么 5 // 5 的结果是 1。这个结果表示，在剩下的字符中，你最多可以组成 1 个 b 字符串。

在这段代码中，// v 用来确定你能用剩余的字符来组成多少个 b 字符串。这里的逻辑是将剩余的字符数除以每个 b 字符串需要的字符数，从而确定最多可以组成多少个 b 字符串。


原来如此





## 第三题

题意
给你一颗树，包含 n 个节点和 n-1 条边，你可以在树中选两个节点进行连无向边，要求连边后的无向图是二分图，问你能连接的最多的边的个数。

输入：

一行一个整数 n, 接下来 n-1 行输入树的边

输出：

能增加的最多的边的条数

样例

输入：

    4
    1 2
    2 3
    3 4
输出：

2


一看就看不懂

本次比试难度适中，没有特别刁钻的题目。第一题简单的贪心，分析一下不难写出来。第二题也是基础的哈希的应用，难度不大。第三题是经典图论问题，dfs遍历即可，注意不要重复遍历。

这他妈


二分图染色，将节点分为两个集合，那么两个集合的点相互连边，这样可以保证结果仍是二分图。假设两个集合个数为 x, y=n-x , 那么答案为 x*y-(n-1)

二分图の定义

        二分图又叫二部图，是图论中的一种特殊模型。

        假设S=(V,E)是一个无向图。如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边(i,j)所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，就可以称图S为一个二分图。简单来说，就是顶点集V可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。

![alt text](assets_picture/牛客题/image.png)

已经很像数学题了        

这题完全不懂


二分图（Bipartite Graph）是一种特殊的图，其中的节点可以被分成两个独立的集合，使得图中的每条边都连接这两个集合中的一个节点。换句话说，二分图中的节点集合可以被划分成两个互不相交的集合，使得所有的边都只在这两个集合之间连接，而不在同一集合内部连接。

图像示例
考虑一个简单的二分图示例：

图 1

    1      2
    |      |
    3      4
这个图是一个二分图，因为你可以将节点分为两组：

集合 𝑈
={
1
,
4
}
U={1,4}

集合 𝑉
={
2
,
3
}
V={2,3}


{竟然可以当成标题

所有的边都连接这两个集合的一个节点。具体来说：

边 
(
1
,
2
)
(1,2) 连接 
𝑈
U 中的节点 1 和 
𝑉
V 中的节点 2。
边 
(
1
,
3
)
(1,3) 连接 
𝑈
U 中的节点 1 和 
𝑉
V 中的节点 3。
边 
(
2
,
4
)
(2,4) 连接 
𝑉
V 中的节点 2 和 
𝑈
U 中的节点 4。
边 
(
3
,
4
)
(3,4) 连接 
𝑉
V 中的节点 3 和 
𝑈
U 中的节点 4。
你可以看到，这个图没有包含奇数长度的环（例如长度为 3 的环），所以它是一个二分图。


图 2（不是二分图）

    1
    / \
    2 - 3
这个图不是二分图，因为它包含了一个长度为 3 的环（1 → 2 → 3 → 1）。在二分图中，我们无法将其节点分为两个集合，使得每条边都连接不同集合中的节点。


如何判断一个图是否是二分图        
判断一个图是否是二分图的一种常用方法是使用 广度优先搜索（BFS） 或 深度优先搜索（DFS） 来尝试对图进行二分着色。如果在搜索过程中发现两个相邻的节点被着上了相同的颜色，则图不是二分图。




二分图（Bipartite Graph）是一种特殊的图，其中的节点可以被分成两个独立的集合，使得图中的每条边都连接这两个集合中的一个节点。换句话说，二分图中的节点集合可以被划分成两个互不相交的集合，使得所有的边都只在这两个集合之间连接，而不在同一集合内部连接。

二分图的性质
节点划分: 二分图的节点集合可以被划分为两个集合 
𝑈
U 和 
𝑉
V，使得每条边的两个端点分别属于这两个集合中的一个。
无奇环: 一个图是二分图的当且仅当它不包含奇数长度的环（循环）。即，二分图不能包含任何长度为奇数的环。
图的着色: 二分图可以用两种颜色来着色，使得相邻的节点颜色不同。
图像示例
考虑一个简单的二分图示例：

图 1
yaml
复制代码
   1      2
   |      |
   3      4
这个图是一个二分图，因为你可以将节点分为两组：

集合 
𝑈
={
1
,
4
}
U={1,4}
集合 
𝑉
={
2
,
3
}
V={2,3}
所有的边都连接这两个集合的一个节点。具体来说：

边 
(
1
,
2
)
(1,2) 连接 
𝑈
U 中的节点 1 和 
𝑉
V 中的节点 2。
边 
(
1
,
3
)
(1,3) 连接 
𝑈
U 中的节点 1 和 
𝑉
V 中的节点 3。
边 
(
2
,
4
)
(2,4) 连接 
𝑉
V 中的节点 2 和 
𝑈
U 中的节点 4。
边 
(
3
,
4
)
(3,4) 连接 
𝑉
V 中的节点 3 和 
𝑈
U 中的节点 4。
你可以看到，这个图没有包含奇数长度的环（例如长度为 3 的环），所以它是一个二分图。

图 2（不是二分图）
复制代码
   1
  / \
 2 - 3
这个图不是二分图，因为它包含了一个长度为 3 的环（1 → 2 → 3 → 1）。在二分图中，我们无法将其节点分为两个集合，使得每条边都连接不同集合中的节点。

如何判断一个图是否是二分图
判断一个图是否是二分图的一种常用方法是使用 广度优先搜索（BFS） 或 深度优先搜索（DFS） 来尝试对图进行二分着色。如果在搜索过程中发现两个相邻的节点被着上了相同的颜色，则图不是二分图。

示例代码
下面是一个使用 BFS 判断一个图是否是二分图的 Python 代码示例：


    from collections import deque, defaultdict

    def is_bipartite(graph, start):
        color = {}
        queue = deque([start])
        color[start] = 0
        
        while queue:
            node = queue.popleft()
            current_color = color[node]
            
            for neighbor in graph[node]:
                if neighbor not in color:
                    color[neighbor] = 1 - current_color
                    queue.append(neighbor)
                elif color[neighbor] == current_color:
                    return False
        
        return True

    def check_bipartite(graph):
        for node in graph:
            if node not in color:
                if not is_bipartite(graph, node):
                    return False
        return True

    # 图的表示：邻接列表
    graph = {
        1: [2, 3],
        2: [1, 3],
        3: [1, 2]
    }

    color = {}
    print("The graph is bipartite:" if check_bipartite(graph) else "The graph is not bipartite.")
在这个示例中，graph 是一个用邻接列表表示的图。如果图是二分图，程序将输出“图是二分图”；否则，输出“图不是二分图”。


    def solve() -> None:
        n = sint()
        adj = [[] for _ in range(n)]
        for i in range(n - 1):
            x, y = mint()
            adj[x - 1].append(y - 1)
            adj[y - 1].append(x - 1)
        m = 0
        def dfs(u, fa, c):
            nonlocal m
            if not c:
                m += 1
            for v in adj[u]:
                if v != fa:
                    dfs(v, u, not c)
        dfs(0, -1, False)
        print(m * (n - m) - (n - 1))
        

    if __name__ == '__main__':
        solve()


    n = map(int, input().split()) 竟然不行
    adj = [[] for _ in range(n)]
    for i in range(n - 1):
        x, y = map(int, input().split())
        adj[x - 1].append(y - 1)
        adj[y - 1].append(x - 1)


代码挺复杂 但是答案不对       
而且后处理很复杂     

        for v in adj[u]:
            if v != fa:
                dfs(v, u, not c)
    dfs(0, -1, False)
    print(m * (n - m) - (n - 1))

n 表示节点数，树的节点数量为 n。
adj 是一个邻接列表，用于表示树的边。
接下来，读入 n-1 条边，每条边连接两个节点 x 和 y。由于 Python 使用零索引，所以减去 1 来适应零索引的数组。


dfs 函数用于遍历树，并计算满足特定条件的节点数量。
u 是当前节点，fa 是父节点，c 是当前节点的颜色（布尔值）。c 从 False 开始。
如果 c 是 False（即节点 u 的颜色为 False），则增加计数 m。
遍历所有与 u 相邻的节点 v，递归调用 dfs，并切换颜色。


计算结果:


    print(m * (n - m) - (n - 1))
m 代表树的节点被染成 False 颜色的数量。
n - m 是树中被染成 True 颜色的节点数量。
m * (n - m) 计算了 False 节点与 True 节点之间边的数量的期望值。
n - 1 是树中总的边数，因为树有 n-1 条边。
结果是两个集合节点之间的边的数量减去 n - 1。


代码的目的是计算一个树的所有节点被分为两个集合后，这两个集合之间的边数的期望值。具体计算方式是通过对树进行二分颜色处理，统计每种颜色的节点数，然后计算这两个集合之间的边数减去树的总边数（n - 1）。

示例替代输入函数
你可以使用 Python 的内置 input() 函数替代 sint() 和 mint()，例如：


    def sint():
        return int(input().strip())

    def mint():
        return map(int, input().strip().split())

太扯了 辅助了也不懂

什么染色完全不明白

图论占比大吗


## 研发b卷

本次oppo的机考有些卷子出了之前的原题了，还没投的赶紧投了噢，oppo的招聘持续性没有那么强的！

本次比试难度适中。

第1题打卡题，分析出来可以直接秒。

第2题需要分析要求的特点，根据特性来运算，数据很大不能特别暴力。

第3题的n,m比较小，观察到这个点就会好做了。

































# 京东
8.10京东研发岗   
考点分别为：模拟、哈希表/二分查找、贪心+位运算


## 第一题：薯条哥醉酒

![alt text](assets_picture/牛客题/image-1.png)

![alt text](assets_picture/牛客题/image-2.png)

![alt text](assets_picture/牛客题/image-3.png)


![alt text](assets_picture/牛客题/image-4.png)


![alt text](assets_picture/牛客题/image-5.png)


    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]  # 北东南西四个方向
    x, y, dirc = 0, 0, 0  # 定义初始位置,初始前进的方向(北方向)

    s = input()

    for ch in s:
        if ch == 'W':
            x = x + dx[dirc]
            y = y + dy[dirc]
        elif ch == 'A':  # 逆时针旋转90度
            dirc = (dirc - 1 + 4) % 4
        elif ch == 'D':   # 顺时针旋转90度
            dirc = (dirc + 1) % 4

    print(x, y)


这才是人做的

## 第二题：求和对数。 哈希表特殊应用 以key作为 加减结果 的索引


![alt text](assets_picture/牛客题/image-6.png)


样例
输入

    3 4
    1 2 3
输出

    3

![alt text](assets_picture/牛客题/image-7.png)

把值直接当成键记录进去。    
半个counter()

    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    cnts = {}
    for i in range(n):
        if a[i] in cnts:
            cnts[a[i]] += 1
        else:
            cnts[a[i]] = 1
    res = 0
    for i in range(n):
        if k - a[i] in cnts:
            res += cnts[k - a[i]]
    print(res)

## 第三题：区间操作


![alt text](assets_picture/牛客题/image-8.png)


![alt text](assets_picture/牛客题/image-9.png)


样例
输入

    2
    5
    1 1 2 1 1
    5
    1 2 3 4 5
输出

    2
    4


![alt text](assets_picture/牛客题/image-10.png)


没看懂？


    def calc(n):
        cnt = 0
        while n > 0:
            if n & 1:
                n -= 1
            else:
                n //= 2
            cnt += 1
        return cnt

    def solve():
        n = int(input())
        a=list(map(int,input().split()))
        op=[0]*n
        for i in range(n):
            op[i]= calc(a[i])
        res = op[0]
        for i in range(1, n):
            res += max(0, op[i] - op[i - 1])
        print(res)

    t = int(input())
    while t > 0:
        solve()
        t -= 1


calc(n) 函数:

功能：计算将 n 变成 0 所需的步骤数。
逻辑：通过判断 n 是奇数还是偶数来决定操作。如果 n 是奇数，则减去 1；如果是偶数，则除以 2。每次操作都计数，直到 n 变成 0。


solve() 函数:

功能：处理每个测试用例，计算并输出结果。
逻辑：
读取整数 n 和包含 n 个整数的列表 a。
对每个整数计算步骤数，将结果存储在 op 列表中。
计算每个步骤数之间的差异，如果当前值大于前一个值，则累加到 res。

    示例：对于输入 n = 3 和 a = [4, 6, 5]：
    计算步骤数：op = [3, 4, 4]
    差异计算：res = 3 + max(0, 4-3) + max(0, 4-4) = 3 + 1 + 0 = 4




主循环:

功能：处理多个测试用例。
逻辑：读取测试用例数量 t，然后循环调用 solve() 函数处理每个测试用例。
示例：如果 t = 2，会依次处理两个测试用例的输入数据。
整体来说，代码的“ultimate”目标是计算和输出每个测试用例的最终结果，即所有数值的“变换步骤数”之和。

还是nlp牛逼


比如现在有3个数字，操作次数分别为2,3,2

那么其实，我们可以先让其操作2次区间，然后再让其操作1次区间即可得到答案。

那么对于第一个数字，我们是一定要花费来进行操作的，然后我们往后面遍历


这块不懂 操作都可以保持一致？万一一个加一个乘呢？


薯条哥有一个长度为且值都为的数组a。对于这个数组薯条哥每次操作可以选择一个区间，对于上的每一个数薯条哥必须让其加一或者乘二(元素之间操作独立，可以选择一些元素乘二，一些元素加一，但是区间内每个元素都要操作)。


始终是题意得问题 第一句和最后一句一直到最后才读懂





# 美团


## 第一题：偶数因子
简单

## 第二题：登录密码

在线测评链接：https://www.sspnote.com/oj/3/342
题目描述
ak机准备登录美团，需要输入密码，ak机忘记了密码，只记得密码可能是字符串中的一个。ak机会按照密码的长度从小到大依次尝试每

个字符串，对于相同长度的字符串，ak机随机尝试，并且相同的密码只会尝试一次。ak机想知道，她最少需要尝试多少次才能登录成功，

最多需要尝试多少次才能登录成功。

ak机不会重新尝试已经尝试过的字符串。成功登录后会立即停止尝试。

![alt text](assets_picture/牛客题/image-11.png)


样例
输入

    4
    ab
    abc
    ab
    ac
    ac
输出

    1 2
样例解释

ak机可能按照 ["ab", "ac", "abc"] 的顺序尝试，第一次尝试成功，也可能按照 ["ac", "ab", "abc"] 的顺序尝试，第二次尝试成功。

ak机在尝试 "ac" 发现不正确后不会继续尝试 "ac"。



# 深信服 事后只会写第二题
只知道 dfs深度有限搜索，动态规划         
不知道回溯法      
我理解就是可以回退 然后找出所有可能        
这和dfs不就是一样吗？            

## 第一题
用dp理不清逻辑，别人也有写出部分的        
牛客说用回溯法？能写出大部分           

类似lc 44题





## 第二题 

    class Solution:
        def twoSum(self, n,k,num):
            dp = [0] * (n+1)
            for i in range(1,n+1):
                if i<k :
                    dp[i]=num[i-1]
                else:
                    dp[i] = max(dp[i-1], dp[i-k]+num[i-1])
            return dp[n]
    print(Solution().twoSum(5,2,[3,2,5,10,7]))


根据牛客别人的说法，竟然确实能硬狗出来 可能不能百分百通过        
牛客提示 dp 然后分情况 对k分情况    
自己想就是 先写出状态转移 硬确定 max分法，直接就设置dp[i-1]为前 i-1的最大


## 第三题据说回溯
















## 回溯法
回溯法（Backtracking）是一种通过探索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化来撤销上一步或上几步的计算，即通过“回溯”来尝试其他的候选解。回溯法通常用于解决组合问题、排列问题、子集问题、图的着色问题、旅行商问题（TSP）等。

例子：解决八皇后问题
八皇后问题是一个经典的问题，要求在一个8x8的`棋盘上放置八个皇后，使得她们互不攻击，即任意两个皇后都不在同一行、同一列或同一对角线上`。

    解题思路
    初始化：创建一个8x8的棋盘，并初始化一个数组来记录每一列上皇后的位置（即行号）。
    放置皇后：从第一行开始，尝试在每一列放置皇后。
    检查冲突：对于每一个放置的皇后，检查其是否与已放置的皇后冲突（同行、同列、同对角线）。
    回溯：如果当前位置无法放置皇后（即存在冲突），则回溯到上一行，尝试在该行的下一列放置皇后。如果当前行所有列都尝试完毕且无法放置，则继续回溯到上一行。
    成功放置：如果成功地在第8行放置了皇后，则找到了一个解。
    寻找所有解：找到一个解后，回溯到上一行，继续寻找其他可能的解。

    初始化棋盘和列位置数组  
    for 第1行到第8行:  
        for 第1列到第8列:  
            如果 当前位置可以放置皇后:  
                放置皇后  
                if 当前行 == 8:  
                    找到一个解，打印棋盘  
                    回溯（移除当前行的皇后）  
                else:  
                    递归到下一行  
            回溯（尝试当前行的下一列）

通过回溯法，我们可以系统地探索所有可能的放置方式，直到找到所有符合条件的解。这种方法虽然可能需要探索大量的候选解，但它能保证找到`所有解`（如果存在的话）。


    def is_safe(board, row, col):  
        # 检查列  
        for i in range(row):  # 只检查已有的，走过的。
            if board[i] == col:  # 这是什么？ board索引是行 值是列 假设0行1列已有值，当到达1行时检查board 发现 for col in range(n): 的col其实不可用
                return False  
        
        # 检查左上对角线  
        for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)):  # 这些设置得比较巧妙 
            if board[i] == j:  
                return False  
        
        # 检查右上对角线  
        for i, j in zip(range(row-1, -1, -1), range(col+1, len(board))):  
            if board[i] == j:  
                return False  
        
        return True  
    
    def solve_n_queens(n):  # 这个函数大概能看懂
        def backtrack(row, board):  
            if row == n:  
                result = [''.join('Q' if j == col else '.' for j in range(n)) for col in board]  
                print('\n'.join(result))  
                return  
            
            for col in range(n):  
                if is_safe(board, row, col):  
                    board[row] = col  
                    backtrack(row + 1, board)  
                    board[row] = -1  # 回溯，重置当前行皇后的位置  
    
        board = [-1] * n  # [-1, -1, -1, -1, -1, -1, -1, -1]
        backtrack(0, board)  
    
    # 调用函数解决8皇后问题  
    solve_n_queens(8)

在这个代码中，is_safe 函数用于检查在棋盘的 (row, col) 位置放置皇后是否安全。它检查同一列、左上对角线和右上对角线上是否有其他皇后。

solve_n_queens 函数是主函数，它接受一个参数 n，表示棋盘的大小（n x n）。它定义了一个内部函数 backtrack，该函数递归地尝试在每一行放置皇后，并使用 board 列表来跟踪每一行皇后的列位置。如果成功地在第 n 行放置了皇后，则找到了一个解决方案，并将其打印出来。然后，它回溯到上一行，尝试其他可能的列位置。

最后，solve_n_queens(8) 调用用于解决8皇后问题，并打印出所有可能的解决方案。

下面是一个使用Python实现的八皇后问题的具体代码示例。这个示例使用了回溯法来找到所有可能的解决方案，并将每个解决方案打印到控制台上。


    Q.......
    ....Q...
    .......Q
    .....Q..
    ..Q.....
    ......Q.
    .Q......
    ...Q....
    Q.......
    .....Q..
    .......Q
    ..Q.....
    ......Q.
    ...Q....





# 结尾